/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SpaceRolesAPIService SpaceRolesAPI service
type SpaceRolesAPIService service

type ApiCreateSpaceRoleRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	createSpaceRoleRequest *CreateSpaceRoleRequest
}

func (r ApiCreateSpaceRoleRequest) CreateSpaceRoleRequest(createSpaceRoleRequest CreateSpaceRoleRequest) ApiCreateSpaceRoleRequest {
	r.createSpaceRoleRequest = &createSpaceRoleRequest
	return r
}

func (r ApiCreateSpaceRoleRequest) Execute() (*SpaceRole, *http.Response, error) {
	return r.ApiService.CreateSpaceRoleExecute(r)
}

/*
CreateSpaceRole Create a space role

Create a space role.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSpaceRoleRequest
*/
func (a *SpaceRolesAPIService) CreateSpaceRole(ctx context.Context) ApiCreateSpaceRoleRequest {
	return ApiCreateSpaceRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpaceRole
func (a *SpaceRolesAPIService) CreateSpaceRoleExecute(r ApiCreateSpaceRoleRequest) (*SpaceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.CreateSpaceRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSpaceRoleRequest == nil {
		return localVarReturnValue, nil, reportError("createSpaceRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSpaceRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSpaceRoleRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	id string
}

func (r ApiDeleteSpaceRoleRequest) Execute() (*DeleteSpaceRoleResponse, *http.Response, error) {
	return r.ApiService.DeleteSpaceRoleExecute(r)
}

/*
DeleteSpaceRole Delete a space role

Delete a space role

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id of the space role
 @return ApiDeleteSpaceRoleRequest
*/
func (a *SpaceRolesAPIService) DeleteSpaceRole(ctx context.Context, id string) ApiDeleteSpaceRoleRequest {
	return ApiDeleteSpaceRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeleteSpaceRoleResponse
func (a *SpaceRolesAPIService) DeleteSpaceRoleExecute(r ApiDeleteSpaceRoleRequest) (*DeleteSpaceRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteSpaceRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.DeleteSpaceRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-roles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableSpaceRolesRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	spaceId *string
	roleType *string
	principalId *string
	principalType *PrincipalType
	cursor *string
	limit *int32
}

// The space ID for which to filter available space roles; if empty, return all available space roles for the tenant.
func (r ApiGetAvailableSpaceRolesRequest) SpaceId(spaceId string) ApiGetAvailableSpaceRolesRequest {
	r.spaceId = &spaceId
	return r
}

// The space role type to filter results by.
func (r ApiGetAvailableSpaceRolesRequest) RoleType(roleType string) ApiGetAvailableSpaceRolesRequest {
	r.roleType = &roleType
	return r
}

// The principal ID to filter results by. If specified, a principal-type must also be specified. Paired with a &#x60;principal-type&#x60; of &#x60;ACCESS_CLASS&#x60;, valid values include [&#x60;anonymous-users&#x60;, &#x60;jsm-project-admins&#x60;, &#x60;authenticated-users&#x60;, &#x60;all-licensed-users&#x60;, &#x60;all-product-admins&#x60;]
func (r ApiGetAvailableSpaceRolesRequest) PrincipalId(principalId string) ApiGetAvailableSpaceRolesRequest {
	r.principalId = &principalId
	return r
}

// The principal type to filter results by. If specified, a principal-id must also be specified.
func (r ApiGetAvailableSpaceRolesRequest) PrincipalType(principalType PrincipalType) ApiGetAvailableSpaceRolesRequest {
	r.principalType = &principalType
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetAvailableSpaceRolesRequest) Cursor(cursor string) ApiGetAvailableSpaceRolesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of space roles to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
func (r ApiGetAvailableSpaceRolesRequest) Limit(limit int32) ApiGetAvailableSpaceRolesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetAvailableSpaceRolesRequest) Execute() (*MultiEntityResultSpaceRole, *http.Response, error) {
	return r.ApiService.GetAvailableSpaceRolesExecute(r)
}

/*
GetAvailableSpaceRoles Get available space roles

Retrieves the available space roles.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site; if requesting a certain space's roles, permission to view the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvailableSpaceRolesRequest
*/
func (a *SpaceRolesAPIService) GetAvailableSpaceRoles(ctx context.Context) ApiGetAvailableSpaceRolesRequest {
	return ApiGetAvailableSpaceRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultSpaceRole
func (a *SpaceRolesAPIService) GetAvailableSpaceRolesExecute(r ApiGetAvailableSpaceRolesRequest) (*MultiEntityResultSpaceRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultSpaceRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.GetAvailableSpaceRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.spaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", r.spaceId, "form", "")
	}
	if r.roleType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role-type", r.roleType, "form", "")
	}
	if r.principalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "principal-id", r.principalId, "form", "")
	}
	if r.principalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "principal-type", r.principalType, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceRoleAssignmentsRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	id int32
	roleId *string
	roleType *string
	principalId *string
	principalType *PrincipalType
	cursor *string
	limit *int32
}

// Filters the returned role assignments to the provided role ID.
func (r ApiGetSpaceRoleAssignmentsRequest) RoleId(roleId string) ApiGetSpaceRoleAssignmentsRequest {
	r.roleId = &roleId
	return r
}

// Filters the returned role assignments to the provided role type.
func (r ApiGetSpaceRoleAssignmentsRequest) RoleType(roleType string) ApiGetSpaceRoleAssignmentsRequest {
	r.roleType = &roleType
	return r
}

// Filters the returned role assignments to the provided principal id. If specified, a principal-type must also be specified. Paired with a &#x60;principal-type&#x60; of &#x60;ACCESS_CLASS&#x60;, valid values include [&#x60;anonymous-users&#x60;, &#x60;jsm-project-admins&#x60;, &#x60;authenticated-users&#x60;, &#x60;all-licensed-users&#x60;, &#x60;all-product-admins&#x60;]
func (r ApiGetSpaceRoleAssignmentsRequest) PrincipalId(principalId string) ApiGetSpaceRoleAssignmentsRequest {
	r.principalId = &principalId
	return r
}

// Filters the returned role assignments to the provided principal type. If specified, a principal-id must also be specified.
func (r ApiGetSpaceRoleAssignmentsRequest) PrincipalType(principalType PrincipalType) ApiGetSpaceRoleAssignmentsRequest {
	r.principalType = &principalType
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetSpaceRoleAssignmentsRequest) Cursor(cursor string) ApiGetSpaceRoleAssignmentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of space roles to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
func (r ApiGetSpaceRoleAssignmentsRequest) Limit(limit int32) ApiGetSpaceRoleAssignmentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSpaceRoleAssignmentsRequest) Execute() (*MultiEntityResultSpaceRoleAssignment, *http.Response, error) {
	return r.ApiService.GetSpaceRoleAssignmentsExecute(r)
}

/*
GetSpaceRoleAssignments Get space role assignments

Retrieves the space role assignments.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which to retrieve assignments.
 @return ApiGetSpaceRoleAssignmentsRequest
*/
func (a *SpaceRolesAPIService) GetSpaceRoleAssignments(ctx context.Context, id int32) ApiGetSpaceRoleAssignmentsRequest {
	return ApiGetSpaceRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultSpaceRoleAssignment
func (a *SpaceRolesAPIService) GetSpaceRoleAssignmentsExecute(r ApiGetSpaceRoleAssignmentsRequest) (*MultiEntityResultSpaceRoleAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultSpaceRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.GetSpaceRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/role-assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role-id", r.roleId, "form", "")
	}
	if r.roleType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role-type", r.roleType, "form", "")
	}
	if r.principalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "principal-id", r.principalId, "form", "")
	}
	if r.principalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "principal-type", r.principalType, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceRoleModeRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
}

func (r ApiGetSpaceRoleModeRequest) Execute() (*GetSpaceRoleMode200Response, *http.Response, error) {
	return r.ApiService.GetSpaceRoleModeExecute(r)
}

/*
GetSpaceRoleMode Get space role mode

Retrieves the space role mode.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpaceRoleModeRequest
*/
func (a *SpaceRolesAPIService) GetSpaceRoleMode(ctx context.Context) ApiGetSpaceRoleModeRequest {
	return ApiGetSpaceRoleModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSpaceRoleMode200Response
func (a *SpaceRolesAPIService) GetSpaceRoleModeExecute(r ApiGetSpaceRoleModeRequest) (*GetSpaceRoleMode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSpaceRoleMode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.GetSpaceRoleMode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-role-mode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceRolesByIdRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	id int32
}

func (r ApiGetSpaceRolesByIdRequest) Execute() (*GetSpaceRolesById200Response, *http.Response, error) {
	return r.ApiService.GetSpaceRolesByIdExecute(r)
}

/*
GetSpaceRolesById Get space role by ID

Retrieves the space role by ID.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space role to retrieve.
 @return ApiGetSpaceRolesByIdRequest
*/
func (a *SpaceRolesAPIService) GetSpaceRolesById(ctx context.Context, id int32) ApiGetSpaceRolesByIdRequest {
	return ApiGetSpaceRolesByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetSpaceRolesById200Response
func (a *SpaceRolesAPIService) GetSpaceRolesByIdExecute(r ApiGetSpaceRolesByIdRequest) (*GetSpaceRolesById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSpaceRolesById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.GetSpaceRolesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-roles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetSpaceRoleAssignmentsRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	id int32
	setSpaceRoleAssignmentsRequestInner *[]SetSpaceRoleAssignmentsRequestInner
}

func (r ApiSetSpaceRoleAssignmentsRequest) SetSpaceRoleAssignmentsRequestInner(setSpaceRoleAssignmentsRequestInner []SetSpaceRoleAssignmentsRequestInner) ApiSetSpaceRoleAssignmentsRequest {
	r.setSpaceRoleAssignmentsRequestInner = &setSpaceRoleAssignmentsRequestInner
	return r
}

func (r ApiSetSpaceRoleAssignmentsRequest) Execute() (*MultiEntityResultSpaceRoleAssignment, *http.Response, error) {
	return r.ApiService.SetSpaceRoleAssignmentsExecute(r)
}

/*
SetSpaceRoleAssignments Set space role assignments

Sets space role assignments as specified in the payload.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to manage roles in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which to retrieve assignments.
 @return ApiSetSpaceRoleAssignmentsRequest
*/
func (a *SpaceRolesAPIService) SetSpaceRoleAssignments(ctx context.Context, id int32) ApiSetSpaceRoleAssignmentsRequest {
	return ApiSetSpaceRoleAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultSpaceRoleAssignment
func (a *SpaceRolesAPIService) SetSpaceRoleAssignmentsExecute(r ApiSetSpaceRoleAssignmentsRequest) (*MultiEntityResultSpaceRoleAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultSpaceRoleAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.SetSpaceRoleAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/role-assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setSpaceRoleAssignmentsRequestInner == nil {
		return localVarReturnValue, nil, reportError("setSpaceRoleAssignmentsRequestInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setSpaceRoleAssignmentsRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSpaceRoleRequest struct {
	ctx context.Context
	ApiService *SpaceRolesAPIService
	id string
	updateSpaceRoleRequest *UpdateSpaceRoleRequest
}

func (r ApiUpdateSpaceRoleRequest) UpdateSpaceRoleRequest(updateSpaceRoleRequest UpdateSpaceRoleRequest) ApiUpdateSpaceRoleRequest {
	r.updateSpaceRoleRequest = &updateSpaceRoleRequest
	return r
}

func (r ApiUpdateSpaceRoleRequest) Execute() (*UpdateSpaceRoleResponse, *http.Response, error) {
	return r.ApiService.UpdateSpaceRoleExecute(r)
}

/*
UpdateSpaceRole Update a space role

Update a space role.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
User must be an organization or site admin. Connect and Forge app users are not authorized to access this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id of the space role
 @return ApiUpdateSpaceRoleRequest
*/
func (a *SpaceRolesAPIService) UpdateSpaceRole(ctx context.Context, id string) ApiUpdateSpaceRoleRequest {
	return ApiUpdateSpaceRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdateSpaceRoleResponse
func (a *SpaceRolesAPIService) UpdateSpaceRoleExecute(r ApiUpdateSpaceRoleRequest) (*UpdateSpaceRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSpaceRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceRolesAPIService.UpdateSpaceRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/space-roles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSpaceRoleRequest == nil {
		return localVarReturnValue, nil, reportError("updateSpaceRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSpaceRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

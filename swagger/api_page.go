/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PageAPIService PageAPI service
type PageAPIService service

type ApiCreatePageRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	createPageRequest *CreatePageRequest
	embedded *bool
	private *bool
	rootLevel *bool
}

func (r ApiCreatePageRequest) CreatePageRequest(createPageRequest CreatePageRequest) ApiCreatePageRequest {
	r.createPageRequest = &createPageRequest
	return r
}

// Tag the content as embedded and content will be created in NCS.
func (r ApiCreatePageRequest) Embedded(embedded bool) ApiCreatePageRequest {
	r.embedded = &embedded
	return r
}

// The page will be private. Only the user who creates this page will have permission to view and edit one.
func (r ApiCreatePageRequest) Private(private bool) ApiCreatePageRequest {
	r.private = &private
	return r
}

// The page will be created at the root level of the space (outside the space homepage tree). If true, then a  value may not be supplied for the &#x60;parentId&#x60; body parameter.
func (r ApiCreatePageRequest) RootLevel(rootLevel bool) ApiCreatePageRequest {
	r.rootLevel = &rootLevel
	return r
}

func (r ApiCreatePageRequest) Execute() (*CreatePage200Response, *http.Response, error) {
	return r.ApiService.CreatePageExecute(r)
}

/*
CreatePage Create page

Creates a page in the space.

Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the corresponding space. Permission to create a page in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePageRequest
*/
func (a *PageAPIService) CreatePage(ctx context.Context) ApiCreatePageRequest {
	return ApiCreatePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePage200Response
func (a *PageAPIService) CreatePageExecute(r ApiCreatePageRequest) (*CreatePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.CreatePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPageRequest == nil {
		return localVarReturnValue, nil, reportError("createPageRequest is required and must be specified")
	}

	if r.embedded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedded", r.embedded, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedded", defaultValue, "form", "")
		r.embedded = &defaultValue
	}
	if r.private != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", r.private, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", defaultValue, "form", "")
		r.private = &defaultValue
	}
	if r.rootLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "root-level", r.rootLevel, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "root-level", defaultValue, "form", "")
		r.rootLevel = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePageRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	purge *bool
	draft *bool
}

// If attempting to purge the page.
func (r ApiDeletePageRequest) Purge(purge bool) ApiDeletePageRequest {
	r.purge = &purge
	return r
}

// If attempting to delete a page that is a draft.
func (r ApiDeletePageRequest) Draft(draft bool) ApiDeletePageRequest {
	r.draft = &draft
	return r
}

func (r ApiDeletePageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePageExecute(r)
}

/*
DeletePage Delete page

Delete a page by id.

By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a 
draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.

Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or "purge" it),
the endpoint must be called on a **trashed** page with the following param `purge=true`.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space.
Permission to delete pages in the space.
Permission to administer the space (if attempting to purge).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to be deleted.
 @return ApiDeletePageRequest
*/
func (a *PageAPIService) DeletePage(ctx context.Context, id int64) ApiDeletePageRequest {
	return ApiDeletePageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PageAPIService) DeletePageExecute(r ApiDeletePageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.DeletePage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", defaultValue, "form", "")
		r.purge = &defaultValue
	}
	if r.draft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "draft", r.draft, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "draft", defaultValue, "form", "")
		r.draft = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLabelPagesRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	spaceId *[]int64
	bodyFormat *PrimaryBodyRepresentation
	sort *PageSortOrder
	cursor *string
	limit *int32
}

// Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
func (r ApiGetLabelPagesRequest) SpaceId(spaceId []int64) ApiGetLabelPagesRequest {
	r.spaceId = &spaceId
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetLabelPagesRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetLabelPagesRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetLabelPagesRequest) Sort(sort PageSortOrder) ApiGetLabelPagesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetLabelPagesRequest) Cursor(cursor string) ApiGetLabelPagesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetLabelPagesRequest) Limit(limit int32) ApiGetLabelPagesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetLabelPagesRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetLabelPagesExecute(r)
}

/*
GetLabelPages Get pages for label

Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the label for which pages should be returned.
 @return ApiGetLabelPagesRequest
*/
func (a *PageAPIService) GetLabelPages(ctx context.Context, id int64) ApiGetLabelPagesRequest {
	return ApiGetLabelPagesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultPage
func (a *PageAPIService) GetLabelPagesExecute(r ApiGetLabelPagesRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.GetLabelPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/labels/{id}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "form", "multi")
		}
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageByIdRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentationSingle
	getDraft *bool
	status *[]string
	version *int32
	includeLabels *bool
	includeProperties *bool
	includeOperations *bool
	includeLikes *bool
	includeVersions *bool
	includeVersion *bool
	includeFavoritedByCurrentUserStatus *bool
	includeWebresources *bool
	includeCollaborators *bool
	includeDirectChildren *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentationSingle) ApiGetPageByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Retrieve the draft version of this page.
func (r ApiGetPageByIdRequest) GetDraft(getDraft bool) ApiGetPageByIdRequest {
	r.getDraft = &getDraft
	return r
}

// Filter the page being retrieved by its status.
func (r ApiGetPageByIdRequest) Status(status []string) ApiGetPageByIdRequest {
	r.status = &status
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetPageByIdRequest) Version(version int32) ApiGetPageByIdRequest {
	r.version = &version
	return r
}

// Includes labels associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetPageByIdRequest) IncludeLabels(includeLabels bool) ApiGetPageByIdRequest {
	r.includeLabels = &includeLabels
	return r
}

// Includes content properties associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetPageByIdRequest) IncludeProperties(includeProperties bool) ApiGetPageByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes operations associated with this page in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetPageByIdRequest) IncludeOperations(includeOperations bool) ApiGetPageByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes likes associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetPageByIdRequest) IncludeLikes(includeLikes bool) ApiGetPageByIdRequest {
	r.includeLikes = &includeLikes
	return r
}

// Includes versions associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetPageByIdRequest) IncludeVersions(includeVersions bool) ApiGetPageByIdRequest {
	r.includeVersions = &includeVersions
	return r
}

// Includes the current version associated with this page in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
func (r ApiGetPageByIdRequest) IncludeVersion(includeVersion bool) ApiGetPageByIdRequest {
	r.includeVersion = &includeVersion
	return r
}

// Includes whether this page has been favorited by the current user.
func (r ApiGetPageByIdRequest) IncludeFavoritedByCurrentUserStatus(includeFavoritedByCurrentUserStatus bool) ApiGetPageByIdRequest {
	r.includeFavoritedByCurrentUserStatus = &includeFavoritedByCurrentUserStatus
	return r
}

// Includes web resources that can be used to render page content on a client.
func (r ApiGetPageByIdRequest) IncludeWebresources(includeWebresources bool) ApiGetPageByIdRequest {
	r.includeWebresources = &includeWebresources
	return r
}

// Includes collaborators on the page.
func (r ApiGetPageByIdRequest) IncludeCollaborators(includeCollaborators bool) ApiGetPageByIdRequest {
	r.includeCollaborators = &includeCollaborators
	return r
}

// Includes direct children of the page, as defined in the &#x60;ChildrenResponse&#x60; object.
func (r ApiGetPageByIdRequest) IncludeDirectChildren(includeDirectChildren bool) ApiGetPageByIdRequest {
	r.includeDirectChildren = &includeDirectChildren
	return r
}

func (r ApiGetPageByIdRequest) Execute() (*CreatePage200Response, *http.Response, error) {
	return r.ApiService.GetPageByIdExecute(r)
}

/*
GetPageById Get page by id

Returns a specific page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results.
 @return ApiGetPageByIdRequest
*/
func (a *PageAPIService) GetPageById(ctx context.Context, id int64) ApiGetPageByIdRequest {
	return ApiGetPageByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePage200Response
func (a *PageAPIService) GetPageByIdExecute(r ApiGetPageByIdRequest) (*CreatePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.GetPageById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.getDraft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", r.getDraft, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", defaultValue, "form", "")
		r.getDraft = &defaultValue
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", r.includeLabels, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", defaultValue, "form", "")
		r.includeLabels = &defaultValue
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeLikes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", r.includeLikes, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", defaultValue, "form", "")
		r.includeLikes = &defaultValue
	}
	if r.includeVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", r.includeVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", defaultValue, "form", "")
		r.includeVersions = &defaultValue
	}
	if r.includeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", r.includeVersion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", defaultValue, "form", "")
		r.includeVersion = &defaultValue
	}
	if r.includeFavoritedByCurrentUserStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-favorited-by-current-user-status", r.includeFavoritedByCurrentUserStatus, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-favorited-by-current-user-status", defaultValue, "form", "")
		r.includeFavoritedByCurrentUserStatus = &defaultValue
	}
	if r.includeWebresources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-webresources", r.includeWebresources, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-webresources", defaultValue, "form", "")
		r.includeWebresources = &defaultValue
	}
	if r.includeCollaborators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", r.includeCollaborators, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", defaultValue, "form", "")
		r.includeCollaborators = &defaultValue
	}
	if r.includeDirectChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-direct-children", r.includeDirectChildren, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-direct-children", defaultValue, "form", "")
		r.includeDirectChildren = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPagesRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id *[]int64
	spaceId *[]int64
	sort *PageSortOrder
	status *[]string
	title *string
	bodyFormat *PrimaryBodyRepresentation
	subtype *string
	cursor *string
	limit *int32
}

// Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.
func (r ApiGetPagesRequest) Id(id []int64) ApiGetPagesRequest {
	r.id = &id
	return r
}

// Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
func (r ApiGetPagesRequest) SpaceId(spaceId []int64) ApiGetPagesRequest {
	r.spaceId = &spaceId
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPagesRequest) Sort(sort PageSortOrder) ApiGetPagesRequest {
	r.sort = &sort
	return r
}

// Filter the results to pages based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
func (r ApiGetPagesRequest) Status(status []string) ApiGetPagesRequest {
	r.status = &status
	return r
}

// Filter the results to pages based on their title.
func (r ApiGetPagesRequest) Title(title string) ApiGetPagesRequest {
	r.title = &title
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPagesRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPagesRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Filter the results to pages based on their subtype.
func (r ApiGetPagesRequest) Subtype(subtype string) ApiGetPagesRequest {
	r.subtype = &subtype
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPagesRequest) Cursor(cursor string) ApiGetPagesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPagesRequest) Limit(limit int32) ApiGetPagesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPagesRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetPagesExecute(r)
}

/*
GetPages Get pages

Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only pages that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPagesRequest
*/
func (a *PageAPIService) GetPages(ctx context.Context) ApiGetPagesRequest {
	return ApiGetPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultPage
func (a *PageAPIService) GetPagesExecute(r ApiGetPagesRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.GetPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.subtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtype", r.subtype, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPagesInSpaceRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	depth *string
	sort *PageSortOrder
	status *[]string
	title *string
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
}

// Filter the results to pages at the root level of the space or to all pages in the space.
func (r ApiGetPagesInSpaceRequest) Depth(depth string) ApiGetPagesInSpaceRequest {
	r.depth = &depth
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPagesInSpaceRequest) Sort(sort PageSortOrder) ApiGetPagesInSpaceRequest {
	r.sort = &sort
	return r
}

// Filter the results to pages based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
func (r ApiGetPagesInSpaceRequest) Status(status []string) ApiGetPagesInSpaceRequest {
	r.status = &status
	return r
}

// Filter the results to pages based on their title.
func (r ApiGetPagesInSpaceRequest) Title(title string) ApiGetPagesInSpaceRequest {
	r.title = &title
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPagesInSpaceRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPagesInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPagesInSpaceRequest) Cursor(cursor string) ApiGetPagesInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPagesInSpaceRequest) Limit(limit int32) ApiGetPagesInSpaceRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPagesInSpaceRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetPagesInSpaceExecute(r)
}

/*
GetPagesInSpace Get pages in space

Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
Only pages that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which pages should be returned.
 @return ApiGetPagesInSpaceRequest
*/
func (a *PageAPIService) GetPagesInSpace(ctx context.Context, id int64) ApiGetPagesInSpaceRequest {
	return ApiGetPagesInSpaceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultPage
func (a *PageAPIService) GetPagesInSpaceExecute(r ApiGetPagesInSpaceRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.GetPagesInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue string = "all"
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", defaultValue, "form", "")
		r.depth = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePageRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	updatePageRequest *UpdatePageRequest
}

func (r ApiUpdatePageRequest) UpdatePageRequest(updatePageRequest UpdatePageRequest) ApiUpdatePageRequest {
	r.updatePageRequest = &updatePageRequest
	return r
}

func (r ApiUpdatePageRequest) Execute() (*CreatePage200Response, *http.Response, error) {
	return r.ApiService.UpdatePageExecute(r)
}

/*
UpdatePage Update page

Update a page by id.

When the "current" version is updated, the provided body content is considered as the latest version. This latest body content
will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged, 
the latest provided content may entirely override what was previously in the draft. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space. Permission to update pages in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results.
 @return ApiUpdatePageRequest
*/
func (a *PageAPIService) UpdatePage(ctx context.Context, id int64) ApiUpdatePageRequest {
	return ApiUpdatePageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePage200Response
func (a *PageAPIService) UpdatePageExecute(r ApiUpdatePageRequest) (*CreatePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.UpdatePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePageRequest == nil {
		return localVarReturnValue, nil, reportError("updatePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePageTitleRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	id int64
	updatePageTitleRequest *UpdatePageTitleRequest
}

func (r ApiUpdatePageTitleRequest) UpdatePageTitleRequest(updatePageTitleRequest UpdatePageTitleRequest) ApiUpdatePageTitleRequest {
	r.updatePageTitleRequest = &updatePageTitleRequest
	return r
}

func (r ApiUpdatePageTitleRequest) Execute() (*CreatePage200Response, *http.Response, error) {
	return r.ApiService.UpdatePageTitleExecute(r)
}

/*
UpdatePageTitle Update page title

Updates the title of a specified page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space. Permission to update pages in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results
 @return ApiUpdatePageTitleRequest
*/
func (a *PageAPIService) UpdatePageTitle(ctx context.Context, id int64) ApiUpdatePageTitleRequest {
	return ApiUpdatePageTitleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreatePage200Response
func (a *PageAPIService) UpdatePageTitleExecute(r ApiUpdatePageTitleRequest) (*CreatePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.UpdatePageTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/title"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePageTitleRequest == nil {
		return localVarReturnValue, nil, reportError("updatePageTitleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePageTitleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

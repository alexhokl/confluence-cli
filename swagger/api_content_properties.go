/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ContentPropertiesAPIService ContentPropertiesAPI service
type ContentPropertiesAPIService service

type ApiCreateAttachmentPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	attachmentId string
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateAttachmentPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateAttachmentPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateAttachmentPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateAttachmentPropertyExecute(r)
}

/*
CreateAttachmentProperty Create content property for attachment

Creates a new content property for an attachment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the attachment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment to create a property for.
 @return ApiCreateAttachmentPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateAttachmentProperty(ctx context.Context, attachmentId string) ApiCreateAttachmentPropertyRequest {
	return ApiCreateAttachmentPropertyRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateAttachmentPropertyExecute(r ApiCreateAttachmentPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateAttachmentProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBlogpostPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	blogpostId int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateBlogpostPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateBlogpostPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateBlogpostPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateBlogpostPropertyExecute(r)
}

/*
CreateBlogpostProperty Create content property for blog post

Creates a new property for a blogpost.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post to create a property for.
 @return ApiCreateBlogpostPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateBlogpostProperty(ctx context.Context, blogpostId int64) ApiCreateBlogpostPropertyRequest {
	return ApiCreateBlogpostPropertyRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateBlogpostPropertyExecute(r ApiCreateBlogpostPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateBlogpostProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCommentPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	commentId int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateCommentPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateCommentPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateCommentPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateCommentPropertyExecute(r)
}

/*
CreateCommentProperty Create content property for comment

Creates a new content property for a comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to create a property for.
 @return ApiCreateCommentPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateCommentProperty(ctx context.Context, commentId int64) ApiCreateCommentPropertyRequest {
	return ApiCreateCommentPropertyRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateCommentPropertyExecute(r ApiCreateCommentPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateCommentProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{comment-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCustomContentPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	customContentId int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateCustomContentPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateCustomContentPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateCustomContentPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateCustomContentPropertyExecute(r)
}

/*
CreateCustomContentProperty Create content property for custom content

Creates a new content property for a piece of custom content.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the custom content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content to create a property for.
 @return ApiCreateCustomContentPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateCustomContentProperty(ctx context.Context, customContentId int64) ApiCreateCustomContentPropertyRequest {
	return ApiCreateCustomContentPropertyRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateCustomContentPropertyExecute(r ApiCreateCustomContentPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateCustomContentProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDatabasePropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateDatabasePropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateDatabasePropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateDatabasePropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateDatabasePropertyExecute(r)
}

/*
CreateDatabaseProperty Create content property for database

Creates a new content property for a database.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the database to create a property for.
 @return ApiCreateDatabasePropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateDatabaseProperty(ctx context.Context, id int64) ApiCreateDatabasePropertyRequest {
	return ApiCreateDatabasePropertyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateDatabasePropertyExecute(r ApiCreateDatabasePropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateDatabaseProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/databases/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFolderPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateFolderPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateFolderPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateFolderPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateFolderPropertyExecute(r)
}

/*
CreateFolderProperty Create content property for folder

Creates a new content property for a folder.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the folder to create a property for.
 @return ApiCreateFolderPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateFolderProperty(ctx context.Context, id int64) ApiCreateFolderPropertyRequest {
	return ApiCreateFolderPropertyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateFolderPropertyExecute(r ApiCreateFolderPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateFolderProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folders/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePagePropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	pageId int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreatePagePropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreatePagePropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreatePagePropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreatePagePropertyExecute(r)
}

/*
CreatePageProperty Create content property for page

Creates a new content property for a page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page to create a property for.
 @return ApiCreatePagePropertyRequest
*/
func (a *ContentPropertiesAPIService) CreatePageProperty(ctx context.Context, pageId int64) ApiCreatePagePropertyRequest {
	return ApiCreatePagePropertyRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreatePagePropertyExecute(r ApiCreatePagePropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreatePageProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSmartLinkPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateSmartLinkPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateSmartLinkPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateSmartLinkPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateSmartLinkPropertyExecute(r)
}

/*
CreateSmartLinkProperty Create content property for Smart Link in the content tree

Creates a new content property for a Smart Link in the content tree.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the Smart Link in the content tree.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the Smart Link in the content tree to create a property for.
 @return ApiCreateSmartLinkPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateSmartLinkProperty(ctx context.Context, id int64) ApiCreateSmartLinkPropertyRequest {
	return ApiCreateSmartLinkPropertyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateSmartLinkPropertyExecute(r ApiCreateSmartLinkPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateSmartLinkProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embeds/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWhiteboardPropertyRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	contentPropertyCreateRequest *ContentPropertyCreateRequest
}

// The content property to be created
func (r ApiCreateWhiteboardPropertyRequest) ContentPropertyCreateRequest(contentPropertyCreateRequest ContentPropertyCreateRequest) ApiCreateWhiteboardPropertyRequest {
	r.contentPropertyCreateRequest = &contentPropertyCreateRequest
	return r
}

func (r ApiCreateWhiteboardPropertyRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.CreateWhiteboardPropertyExecute(r)
}

/*
CreateWhiteboardProperty Create content property for whiteboard

Creates a new content property for a whiteboard.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to update the whiteboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the whiteboard to create a property for.
 @return ApiCreateWhiteboardPropertyRequest
*/
func (a *ContentPropertiesAPIService) CreateWhiteboardProperty(ctx context.Context, id int64) ApiCreateWhiteboardPropertyRequest {
	return ApiCreateWhiteboardPropertyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) CreateWhiteboardPropertyExecute(r ApiCreateWhiteboardPropertyRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.CreateWhiteboardProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAttachmentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	attachmentId string
	propertyId int64
}

func (r ApiDeleteAttachmentPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAttachmentPropertyByIdExecute(r)
}

/*
DeleteAttachmentPropertyById Delete content property for attachment by id

Deletes a content property for an attachment by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to attachment the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteAttachmentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64) ApiDeleteAttachmentPropertyByIdRequest {
	return ApiDeleteAttachmentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteAttachmentPropertyByIdExecute(r ApiDeleteAttachmentPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteAttachmentPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBlogpostPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	blogpostId int64
	propertyId int64
}

func (r ApiDeleteBlogpostPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBlogpostPropertyByIdExecute(r)
}

/*
DeleteBlogpostPropertyById Delete content property for blogpost by id

Deletes a content property for a blogpost by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteBlogpostPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64) ApiDeleteBlogpostPropertyByIdRequest {
	return ApiDeleteBlogpostPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteBlogpostPropertyByIdExecute(r ApiDeleteBlogpostPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteBlogpostPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCommentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	commentId int64
	propertyId int64
}

func (r ApiDeleteCommentPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentPropertyByIdExecute(r)
}

/*
DeleteCommentPropertyById Delete content property for comment by id

Deletes a content property for a comment by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteCommentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteCommentPropertyById(ctx context.Context, commentId int64, propertyId int64) ApiDeleteCommentPropertyByIdRequest {
	return ApiDeleteCommentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteCommentPropertyByIdExecute(r ApiDeleteCommentPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteCommentPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{comment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCustomContentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	customContentId int64
	propertyId int64
}

func (r ApiDeleteCustomContentPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomContentPropertyByIdExecute(r)
}

/*
DeleteCustomContentPropertyById Delete content property for custom content by id

Deletes a content property for a piece of custom content by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the custom content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteCustomContentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64) ApiDeleteCustomContentPropertyByIdRequest {
	return ApiDeleteCustomContentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteCustomContentPropertyByIdExecute(r ApiDeleteCustomContentPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteCustomContentPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDatabasePropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	databaseId int64
	propertyId int64
}

func (r ApiDeleteDatabasePropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDatabasePropertyByIdExecute(r)
}

/*
DeleteDatabasePropertyById Delete content property for database by id

Deletes a content property for a database by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId The ID of the database the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteDatabasePropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64) ApiDeleteDatabasePropertyByIdRequest {
	return ApiDeleteDatabasePropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteDatabasePropertyByIdExecute(r ApiDeleteDatabasePropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteDatabasePropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/databases/{database-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"database-id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFolderPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	folderId int64
	propertyId int64
}

func (r ApiDeleteFolderPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFolderPropertyByIdExecute(r)
}

/*
DeleteFolderPropertyById Delete content property for folder by id

Deletes a content property for a folder by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId The ID of the folder the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteFolderPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteFolderPropertyById(ctx context.Context, folderId int64, propertyId int64) ApiDeleteFolderPropertyByIdRequest {
	return ApiDeleteFolderPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteFolderPropertyByIdExecute(r ApiDeleteFolderPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteFolderPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folders/{folder-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"folder-id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePagePropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	pageId int64
	propertyId int64
}

func (r ApiDeletePagePropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePagePropertyByIdExecute(r)
}

/*
DeletePagePropertyById Delete content property for page by id

Deletes a content property for a page by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeletePagePropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeletePagePropertyById(ctx context.Context, pageId int64, propertyId int64) ApiDeletePagePropertyByIdRequest {
	return ApiDeletePagePropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeletePagePropertyByIdExecute(r ApiDeletePagePropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeletePagePropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSmartLinkPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	embedId int64
	propertyId int64
}

func (r ApiDeleteSmartLinkPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSmartLinkPropertyByIdExecute(r)
}

/*
DeleteSmartLinkPropertyById Delete content property for Smart Link in the content tree by id

Deletes a content property for a Smart Link in the content tree by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the Smart Link in the content tree.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param embedId The ID of the Smart Link in the content tree the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteSmartLinkPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64) ApiDeleteSmartLinkPropertyByIdRequest {
	return ApiDeleteSmartLinkPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		embedId: embedId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteSmartLinkPropertyByIdExecute(r ApiDeleteSmartLinkPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteSmartLinkPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embeds/{embed-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"embed-id"+"}", url.PathEscape(parameterValueToString(r.embedId, "embedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWhiteboardPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	whiteboardId int64
	propertyId int64
}

func (r ApiDeleteWhiteboardPropertyByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWhiteboardPropertyByIdExecute(r)
}

/*
DeleteWhiteboardPropertyById Delete content property for whiteboard by id

Deletes a content property for a whiteboard by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the whiteboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whiteboardId The ID of the whiteboard the property belongs to.
 @param propertyId The ID of the property to be deleted.
 @return ApiDeleteWhiteboardPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) DeleteWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64) ApiDeleteWhiteboardPropertyByIdRequest {
	return ApiDeleteWhiteboardPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		whiteboardId: whiteboardId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ContentPropertiesAPIService) DeleteWhiteboardPropertyByIdExecute(r ApiDeleteWhiteboardPropertyByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.DeleteWhiteboardPropertyById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{whiteboard-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"whiteboard-id"+"}", url.PathEscape(parameterValueToString(r.whiteboardId, "whiteboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAttachmentContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	attachmentId string
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetAttachmentContentPropertiesRequest) Key(key string) ApiGetAttachmentContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetAttachmentContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetAttachmentContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetAttachmentContentPropertiesRequest) Cursor(cursor string) ApiGetAttachmentContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetAttachmentContentPropertiesRequest) Limit(limit int32) ApiGetAttachmentContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetAttachmentContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetAttachmentContentPropertiesExecute(r)
}

/*
GetAttachmentContentProperties Get content properties for attachment

Retrieves all Content Properties tied to a specified attachment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the attachment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment for which content properties should be returned.
 @return ApiGetAttachmentContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetAttachmentContentProperties(ctx context.Context, attachmentId string) ApiGetAttachmentContentPropertiesRequest {
	return ApiGetAttachmentContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetAttachmentContentPropertiesExecute(r ApiGetAttachmentContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetAttachmentContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttachmentContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	attachmentId string
	propertyId int64
}

func (r ApiGetAttachmentContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetAttachmentContentPropertiesByIdExecute(r)
}

/*
GetAttachmentContentPropertiesById Get content property for attachment by id

Retrieves a specific Content Property by ID that is attached to a specified attachment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the attachment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment for which content properties should be returned.
 @param propertyId The ID of the content property to be returned
 @return ApiGetAttachmentContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetAttachmentContentPropertiesById(ctx context.Context, attachmentId string, propertyId int64) ApiGetAttachmentContentPropertiesByIdRequest {
	return ApiGetAttachmentContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetAttachmentContentPropertiesByIdExecute(r ApiGetAttachmentContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetAttachmentContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogpostContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	blogpostId int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetBlogpostContentPropertiesRequest) Key(key string) ApiGetBlogpostContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogpostContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetBlogpostContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogpostContentPropertiesRequest) Cursor(cursor string) ApiGetBlogpostContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogpostContentPropertiesRequest) Limit(limit int32) ApiGetBlogpostContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogpostContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetBlogpostContentPropertiesExecute(r)
}

/*
GetBlogpostContentProperties Get content properties for blog post

Retrieves all Content Properties tied to a specified blog post.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post for which content properties should be returned.
 @return ApiGetBlogpostContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetBlogpostContentProperties(ctx context.Context, blogpostId int64) ApiGetBlogpostContentPropertiesRequest {
	return ApiGetBlogpostContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetBlogpostContentPropertiesExecute(r ApiGetBlogpostContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetBlogpostContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogpostContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	blogpostId int64
	propertyId int64
}

func (r ApiGetBlogpostContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetBlogpostContentPropertiesByIdExecute(r)
}

/*
GetBlogpostContentPropertiesById Get content property for blog post by id

Retrieves a specific Content Property by ID that is attached to a specified blog post.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post for which content properties should be returned.
 @param propertyId The ID of the property being requested
 @return ApiGetBlogpostContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetBlogpostContentPropertiesById(ctx context.Context, blogpostId int64, propertyId int64) ApiGetBlogpostContentPropertiesByIdRequest {
	return ApiGetBlogpostContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetBlogpostContentPropertiesByIdExecute(r ApiGetBlogpostContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetBlogpostContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	commentId int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetCommentContentPropertiesRequest) Key(key string) ApiGetCommentContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCommentContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetCommentContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCommentContentPropertiesRequest) Cursor(cursor string) ApiGetCommentContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCommentContentPropertiesRequest) Limit(limit int32) ApiGetCommentContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCommentContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetCommentContentPropertiesExecute(r)
}

/*
GetCommentContentProperties Get content properties for comment

Retrieves Content Properties attached to a specified comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment for which content properties should be returned.
 @return ApiGetCommentContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetCommentContentProperties(ctx context.Context, commentId int64) ApiGetCommentContentPropertiesRequest {
	return ApiGetCommentContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetCommentContentPropertiesExecute(r ApiGetCommentContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetCommentContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{comment-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	commentId int64
	propertyId int64
}

func (r ApiGetCommentContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetCommentContentPropertiesByIdExecute(r)
}

/*
GetCommentContentPropertiesById Get content property for comment by id

Retrieves a specific Content Property by ID that is attached to a specified comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetCommentContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetCommentContentPropertiesById(ctx context.Context, commentId int64, propertyId int64) ApiGetCommentContentPropertiesByIdRequest {
	return ApiGetCommentContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetCommentContentPropertiesByIdExecute(r ApiGetCommentContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetCommentContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{comment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	customContentId int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetCustomContentContentPropertiesRequest) Key(key string) ApiGetCustomContentContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetCustomContentContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentContentPropertiesRequest) Cursor(cursor string) ApiGetCustomContentContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentContentPropertiesRequest) Limit(limit int32) ApiGetCustomContentContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCustomContentContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetCustomContentContentPropertiesExecute(r)
}

/*
GetCustomContentContentProperties Get content properties for custom content

Retrieves Content Properties tied to a specified custom content.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content for which content properties should be returned.
 @return ApiGetCustomContentContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetCustomContentContentProperties(ctx context.Context, customContentId int64) ApiGetCustomContentContentPropertiesRequest {
	return ApiGetCustomContentContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetCustomContentContentPropertiesExecute(r ApiGetCustomContentContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetCustomContentContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	customContentId int64
	propertyId int64
}

func (r ApiGetCustomContentContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetCustomContentContentPropertiesByIdExecute(r)
}

/*
GetCustomContentContentPropertiesById Get content property for custom content by id

Retrieves a specific Content Property by ID that is attached to a specified custom content.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetCustomContentContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetCustomContentContentPropertiesById(ctx context.Context, customContentId int64, propertyId int64) ApiGetCustomContentContentPropertiesByIdRequest {
	return ApiGetCustomContentContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetCustomContentContentPropertiesByIdExecute(r ApiGetCustomContentContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetCustomContentContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetDatabaseContentPropertiesRequest) Key(key string) ApiGetDatabaseContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetDatabaseContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetDatabaseContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetDatabaseContentPropertiesRequest) Cursor(cursor string) ApiGetDatabaseContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetDatabaseContentPropertiesRequest) Limit(limit int32) ApiGetDatabaseContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDatabaseContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetDatabaseContentPropertiesExecute(r)
}

/*
GetDatabaseContentProperties Get content properties for database

Retrieves Content Properties tied to a specified database.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the database for which content properties should be returned.
 @return ApiGetDatabaseContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetDatabaseContentProperties(ctx context.Context, id int64) ApiGetDatabaseContentPropertiesRequest {
	return ApiGetDatabaseContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetDatabaseContentPropertiesExecute(r ApiGetDatabaseContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetDatabaseContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/databases/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	databaseId int64
	propertyId int64
}

func (r ApiGetDatabaseContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetDatabaseContentPropertiesByIdExecute(r)
}

/*
GetDatabaseContentPropertiesById Get content property for database by id

Retrieves a specific Content Property by ID that is attached to a specified database.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId The ID of the database for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetDatabaseContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetDatabaseContentPropertiesById(ctx context.Context, databaseId int64, propertyId int64) ApiGetDatabaseContentPropertiesByIdRequest {
	return ApiGetDatabaseContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetDatabaseContentPropertiesByIdExecute(r ApiGetDatabaseContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetDatabaseContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/databases/{database-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"database-id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolderContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetFolderContentPropertiesRequest) Key(key string) ApiGetFolderContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetFolderContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetFolderContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetFolderContentPropertiesRequest) Cursor(cursor string) ApiGetFolderContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetFolderContentPropertiesRequest) Limit(limit int32) ApiGetFolderContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetFolderContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetFolderContentPropertiesExecute(r)
}

/*
GetFolderContentProperties Get content properties for folder

Retrieves Content Properties tied to a specified folder.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the folder for which content properties should be returned.
 @return ApiGetFolderContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetFolderContentProperties(ctx context.Context, id int64) ApiGetFolderContentPropertiesRequest {
	return ApiGetFolderContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetFolderContentPropertiesExecute(r ApiGetFolderContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetFolderContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folders/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolderContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	folderId int64
	propertyId int64
}

func (r ApiGetFolderContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetFolderContentPropertiesByIdExecute(r)
}

/*
GetFolderContentPropertiesById Get content property for folder by id

Retrieves a specific Content Property by ID that is attached to a specified folder.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId The ID of the folder for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetFolderContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetFolderContentPropertiesById(ctx context.Context, folderId int64, propertyId int64) ApiGetFolderContentPropertiesByIdRequest {
	return ApiGetFolderContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetFolderContentPropertiesByIdExecute(r ApiGetFolderContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetFolderContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folders/{folder-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"folder-id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	pageId int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetPageContentPropertiesRequest) Key(key string) ApiGetPageContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetPageContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageContentPropertiesRequest) Cursor(cursor string) ApiGetPageContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageContentPropertiesRequest) Limit(limit int32) ApiGetPageContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPageContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetPageContentPropertiesExecute(r)
}

/*
GetPageContentProperties Get content properties for page

Retrieves Content Properties tied to a specified page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page for which content properties should be returned.
 @return ApiGetPageContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetPageContentProperties(ctx context.Context, pageId int64) ApiGetPageContentPropertiesRequest {
	return ApiGetPageContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetPageContentPropertiesExecute(r ApiGetPageContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetPageContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	pageId int64
	propertyId int64
}

func (r ApiGetPageContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetPageContentPropertiesByIdExecute(r)
}

/*
GetPageContentPropertiesById Get content property for page by id

Retrieves a specific Content Property by ID that is attached to a specified page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetPageContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetPageContentPropertiesById(ctx context.Context, pageId int64, propertyId int64) ApiGetPageContentPropertiesByIdRequest {
	return ApiGetPageContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetPageContentPropertiesByIdExecute(r ApiGetPageContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetPageContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmartLinkContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetSmartLinkContentPropertiesRequest) Key(key string) ApiGetSmartLinkContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetSmartLinkContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetSmartLinkContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetSmartLinkContentPropertiesRequest) Cursor(cursor string) ApiGetSmartLinkContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of Smart Links per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetSmartLinkContentPropertiesRequest) Limit(limit int32) ApiGetSmartLinkContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSmartLinkContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetSmartLinkContentPropertiesExecute(r)
}

/*
GetSmartLinkContentProperties Get content properties for Smart Link in the content tree

Retrieves Content Properties tied to a specified Smart Link in the content tree.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the Smart Link in the content tree.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the Smart Link in the content tree for which content properties should be returned.
 @return ApiGetSmartLinkContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetSmartLinkContentProperties(ctx context.Context, id int64) ApiGetSmartLinkContentPropertiesRequest {
	return ApiGetSmartLinkContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetSmartLinkContentPropertiesExecute(r ApiGetSmartLinkContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetSmartLinkContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embeds/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmartLinkContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	embedId int64
	propertyId int64
}

func (r ApiGetSmartLinkContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetSmartLinkContentPropertiesByIdExecute(r)
}

/*
GetSmartLinkContentPropertiesById Get content property for Smart Link in the content tree by id

Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the Smart Link in the content tree.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param embedId The ID of the Smart Link in the content tree for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetSmartLinkContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetSmartLinkContentPropertiesById(ctx context.Context, embedId int64, propertyId int64) ApiGetSmartLinkContentPropertiesByIdRequest {
	return ApiGetSmartLinkContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		embedId: embedId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetSmartLinkContentPropertiesByIdExecute(r ApiGetSmartLinkContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetSmartLinkContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embeds/{embed-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"embed-id"+"}", url.PathEscape(parameterValueToString(r.embedId, "embedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWhiteboardContentPropertiesRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	id int64
	key *string
	sort *ContentPropertySortOrder
	cursor *string
	limit *int32
}

// Filters the response to return a specific content property with matching key (case sensitive).
func (r ApiGetWhiteboardContentPropertiesRequest) Key(key string) ApiGetWhiteboardContentPropertiesRequest {
	r.key = &key
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetWhiteboardContentPropertiesRequest) Sort(sort ContentPropertySortOrder) ApiGetWhiteboardContentPropertiesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetWhiteboardContentPropertiesRequest) Cursor(cursor string) ApiGetWhiteboardContentPropertiesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetWhiteboardContentPropertiesRequest) Limit(limit int32) ApiGetWhiteboardContentPropertiesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetWhiteboardContentPropertiesRequest) Execute() (*MultiEntityResultContentProperty, *http.Response, error) {
	return r.ApiService.GetWhiteboardContentPropertiesExecute(r)
}

/*
GetWhiteboardContentProperties Get content properties for whiteboard

Retrieves Content Properties tied to a specified whiteboard.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the whiteboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the whiteboard for which content properties should be returned.
 @return ApiGetWhiteboardContentPropertiesRequest
*/
func (a *ContentPropertiesAPIService) GetWhiteboardContentProperties(ctx context.Context, id int64) ApiGetWhiteboardContentPropertiesRequest {
	return ApiGetWhiteboardContentPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultContentProperty
func (a *ContentPropertiesAPIService) GetWhiteboardContentPropertiesExecute(r ApiGetWhiteboardContentPropertiesRequest) (*MultiEntityResultContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetWhiteboardContentProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWhiteboardContentPropertiesByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	whiteboardId int64
	propertyId int64
}

func (r ApiGetWhiteboardContentPropertiesByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.GetWhiteboardContentPropertiesByIdExecute(r)
}

/*
GetWhiteboardContentPropertiesById Get content property for whiteboard by id

Retrieves a specific Content Property by ID that is attached to a specified whiteboard.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the whiteboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whiteboardId The ID of the whiteboard for which content properties should be returned.
 @param propertyId The ID of the content property being requested.
 @return ApiGetWhiteboardContentPropertiesByIdRequest
*/
func (a *ContentPropertiesAPIService) GetWhiteboardContentPropertiesById(ctx context.Context, whiteboardId int64, propertyId int64) ApiGetWhiteboardContentPropertiesByIdRequest {
	return ApiGetWhiteboardContentPropertiesByIdRequest{
		ApiService: a,
		ctx: ctx,
		whiteboardId: whiteboardId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) GetWhiteboardContentPropertiesByIdExecute(r ApiGetWhiteboardContentPropertiesByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.GetWhiteboardContentPropertiesById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{whiteboard-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"whiteboard-id"+"}", url.PathEscape(parameterValueToString(r.whiteboardId, "whiteboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAttachmentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	attachmentId string
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateAttachmentPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateAttachmentPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateAttachmentPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateAttachmentPropertyByIdExecute(r)
}

/*
UpdateAttachmentPropertyById Update content property for attachment by id

Update a content property for attachment by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the attachment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateAttachmentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64) ApiUpdateAttachmentPropertyByIdRequest {
	return ApiUpdateAttachmentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateAttachmentPropertyByIdExecute(r ApiUpdateAttachmentPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateAttachmentPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlogpostPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	blogpostId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateBlogpostPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateBlogpostPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateBlogpostPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateBlogpostPropertyByIdExecute(r)
}

/*
UpdateBlogpostPropertyById Update content property for blog post by id

Update a content property for blog post by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateBlogpostPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64) ApiUpdateBlogpostPropertyByIdRequest {
	return ApiUpdateBlogpostPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateBlogpostPropertyByIdExecute(r ApiUpdateBlogpostPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateBlogpostPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCommentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	commentId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateCommentPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateCommentPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateCommentPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateCommentPropertyByIdExecute(r)
}

/*
UpdateCommentPropertyById Update content property for comment by id

Update a content property for a comment by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateCommentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateCommentPropertyById(ctx context.Context, commentId int64, propertyId int64) ApiUpdateCommentPropertyByIdRequest {
	return ApiUpdateCommentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateCommentPropertyByIdExecute(r ApiUpdateCommentPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateCommentPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{comment-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomContentPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	customContentId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateCustomContentPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateCustomContentPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateCustomContentPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateCustomContentPropertyByIdExecute(r)
}

/*
UpdateCustomContentPropertyById Update content property for custom content by id

Update a content property for a piece of custom content by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the custom content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateCustomContentPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64) ApiUpdateCustomContentPropertyByIdRequest {
	return ApiUpdateCustomContentPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateCustomContentPropertyByIdExecute(r ApiUpdateCustomContentPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateCustomContentPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDatabasePropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	databaseId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateDatabasePropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateDatabasePropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateDatabasePropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateDatabasePropertyByIdExecute(r)
}

/*
UpdateDatabasePropertyById Update content property for database by id

Update a content property for a database by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId The ID of the database the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateDatabasePropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64) ApiUpdateDatabasePropertyByIdRequest {
	return ApiUpdateDatabasePropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateDatabasePropertyByIdExecute(r ApiUpdateDatabasePropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateDatabasePropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/databases/{database-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"database-id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFolderPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	folderId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateFolderPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateFolderPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateFolderPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateFolderPropertyByIdExecute(r)
}

/*
UpdateFolderPropertyById Update content property for folder by id

Update a content property for a folder by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId The ID of the folder the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateFolderPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateFolderPropertyById(ctx context.Context, folderId int64, propertyId int64) ApiUpdateFolderPropertyByIdRequest {
	return ApiUpdateFolderPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateFolderPropertyByIdExecute(r ApiUpdateFolderPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateFolderPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folders/{folder-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"folder-id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePagePropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	pageId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdatePagePropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdatePagePropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdatePagePropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdatePagePropertyByIdExecute(r)
}

/*
UpdatePagePropertyById Update content property for page by id

Update a content property for a page by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdatePagePropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdatePagePropertyById(ctx context.Context, pageId int64, propertyId int64) ApiUpdatePagePropertyByIdRequest {
	return ApiUpdatePagePropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdatePagePropertyByIdExecute(r ApiUpdatePagePropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdatePagePropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSmartLinkPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	embedId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateSmartLinkPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateSmartLinkPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateSmartLinkPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateSmartLinkPropertyByIdExecute(r)
}

/*
UpdateSmartLinkPropertyById Update content property for Smart Link in the content tree by id

Update a content property for a Smart Link in the content tree by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the Smart Link in the content tree.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param embedId The ID of the Smart Link in the content tree the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateSmartLinkPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64) ApiUpdateSmartLinkPropertyByIdRequest {
	return ApiUpdateSmartLinkPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		embedId: embedId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateSmartLinkPropertyByIdExecute(r ApiUpdateSmartLinkPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateSmartLinkPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embeds/{embed-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"embed-id"+"}", url.PathEscape(parameterValueToString(r.embedId, "embedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWhiteboardPropertyByIdRequest struct {
	ctx context.Context
	ApiService *ContentPropertiesAPIService
	whiteboardId int64
	propertyId int64
	contentPropertyUpdateRequest *ContentPropertyUpdateRequest
}

// The content property to be updated.
func (r ApiUpdateWhiteboardPropertyByIdRequest) ContentPropertyUpdateRequest(contentPropertyUpdateRequest ContentPropertyUpdateRequest) ApiUpdateWhiteboardPropertyByIdRequest {
	r.contentPropertyUpdateRequest = &contentPropertyUpdateRequest
	return r
}

func (r ApiUpdateWhiteboardPropertyByIdRequest) Execute() (*ContentProperty, *http.Response, error) {
	return r.ApiService.UpdateWhiteboardPropertyByIdExecute(r)
}

/*
UpdateWhiteboardPropertyById Update content property for whiteboard by id

Update a content property for a whiteboard by its id. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the whiteboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whiteboardId The ID of the whiteboard the property belongs to.
 @param propertyId The ID of the property to be updated.
 @return ApiUpdateWhiteboardPropertyByIdRequest
*/
func (a *ContentPropertiesAPIService) UpdateWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64) ApiUpdateWhiteboardPropertyByIdRequest {
	return ApiUpdateWhiteboardPropertyByIdRequest{
		ApiService: a,
		ctx: ctx,
		whiteboardId: whiteboardId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ContentProperty
func (a *ContentPropertiesAPIService) UpdateWhiteboardPropertyByIdExecute(r ApiUpdateWhiteboardPropertyByIdRequest) (*ContentProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPropertiesAPIService.UpdateWhiteboardPropertyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{whiteboard-id}/properties/{property-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"whiteboard-id"+"}", url.PathEscape(parameterValueToString(r.whiteboardId, "whiteboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property-id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentPropertyUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contentPropertyUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentPropertyUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

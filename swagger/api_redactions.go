/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RedactionsAPIService RedactionsAPI service
type RedactionsAPIService service

type ApiPostRedactBlogRequest struct {
	ctx context.Context
	ApiService *RedactionsAPIService
	id int64
	postRedactPageRequest *PostRedactPageRequest
}

func (r ApiPostRedactBlogRequest) PostRedactPageRequest(postRedactPageRequest PostRedactPageRequest) ApiPostRedactBlogRequest {
	r.postRedactPageRequest = &postRedactPageRequest
	return r
}

func (r ApiPostRedactBlogRequest) Execute() (*RedactionResponse, *http.Response, error) {
	return r.ApiService.PostRedactBlogExecute(r)
}

/*
PostRedactBlog Redact Content in a Confluence Blog Post

Redacts sensitive content in a Confluence blog post by replacing specified text ranges with redaction markers. 
Each redaction in the response includes a unique UUID for restoration (except code block redactions). 
The response metadata items maintain the same order as the input redaction pointers, and completely 
overlapping redactions are merged into a single redaction with one UUID.

**Note**: This endpoint requires **Atlassian Guard Premium**.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post to redact content from.
 @return ApiPostRedactBlogRequest
*/
func (a *RedactionsAPIService) PostRedactBlog(ctx context.Context, id int64) ApiPostRedactBlogRequest {
	return ApiPostRedactBlogRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RedactionResponse
func (a *RedactionsAPIService) PostRedactBlogExecute(r ApiPostRedactBlogRequest) (*RedactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RedactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RedactionsAPIService.PostRedactBlog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/redact"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedactPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedactPageRequest struct {
	ctx context.Context
	ApiService *RedactionsAPIService
	id int64
	postRedactPageRequest *PostRedactPageRequest
}

func (r ApiPostRedactPageRequest) PostRedactPageRequest(postRedactPageRequest PostRedactPageRequest) ApiPostRedactPageRequest {
	r.postRedactPageRequest = &postRedactPageRequest
	return r
}

func (r ApiPostRedactPageRequest) Execute() (*RedactionResponse, *http.Response, error) {
	return r.ApiService.PostRedactPageExecute(r)
}

/*
PostRedactPage Redact Content in a Confluence Page

Redacts sensitive content in a Confluence page by replacing specified text ranges with redaction markers. 
Each redaction in the response includes a unique UUID for restoration (except code block redactions). 
The response metadata items maintain the same order as the input redaction pointers, and completely 
overlapping redactions are merged into a single redaction with one UUID.

**Note**: This endpoint requires **Atlassian Guard Premium**.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to redact content from.
 @return ApiPostRedactPageRequest
*/
func (a *RedactionsAPIService) PostRedactPage(ctx context.Context, id int64) ApiPostRedactPageRequest {
	return ApiPostRedactPageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RedactionResponse
func (a *RedactionsAPIService) PostRedactPageExecute(r ApiPostRedactPageRequest) (*RedactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RedactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RedactionsAPIService.PostRedactPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/redact"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedactPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

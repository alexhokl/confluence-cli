/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CommentAPIService CommentAPI service
type CommentAPIService service

type ApiCreateFooterCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	createFooterCommentModel *CreateFooterCommentModel
}

// The footer comment to be created
func (r ApiCreateFooterCommentRequest) CreateFooterCommentModel(createFooterCommentModel CreateFooterCommentModel) ApiCreateFooterCommentRequest {
	r.createFooterCommentModel = &createFooterCommentModel
	return r
}

func (r ApiCreateFooterCommentRequest) Execute() (*CreateFooterComment201Response, *http.Response, error) {
	return r.ApiService.CreateFooterCommentExecute(r)
}

/*
CreateFooterComment Create footer comment

Create a footer comment.

The footer comment can be made against several locations: 
- at the top level (specifying pageId or blogPostId in the request body)
- as a reply (specifying parentCommentId in the request body)
- against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments)
- against a custom content

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFooterCommentRequest
*/
func (a *CommentAPIService) CreateFooterComment(ctx context.Context) ApiCreateFooterCommentRequest {
	return ApiCreateFooterCommentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFooterComment201Response
func (a *CommentAPIService) CreateFooterCommentExecute(r ApiCreateFooterCommentRequest) (*CreateFooterComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFooterComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.CreateFooterComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFooterCommentModel == nil {
		return localVarReturnValue, nil, reportError("createFooterCommentModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFooterCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInlineCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	createInlineCommentModel *CreateInlineCommentModel
}

// The inline comment to be created
func (r ApiCreateInlineCommentRequest) CreateInlineCommentModel(createInlineCommentModel CreateInlineCommentModel) ApiCreateInlineCommentRequest {
	r.createInlineCommentModel = &createInlineCommentModel
	return r
}

func (r ApiCreateInlineCommentRequest) Execute() (*CreateInlineComment201Response, *http.Response, error) {
	return r.ApiService.CreateInlineCommentExecute(r)
}

/*
CreateInlineComment Create inline comment

Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
request body is used to select the text the inline comment should be tied to. This is what determines the text 
highlighting when viewing a page in Confluence.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateInlineCommentRequest
*/
func (a *CommentAPIService) CreateInlineComment(ctx context.Context) ApiCreateInlineCommentRequest {
	return ApiCreateInlineCommentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateInlineComment201Response
func (a *CommentAPIService) CreateInlineCommentExecute(r ApiCreateInlineCommentRequest) (*CreateInlineComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateInlineComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.CreateInlineComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createInlineCommentModel == nil {
		return localVarReturnValue, nil, reportError("createInlineCommentModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createInlineCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFooterCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
}

func (r ApiDeleteFooterCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFooterCommentExecute(r)
}

/*
DeleteFooterComment Delete footer comment

Deletes a footer comment. This is a permanent deletion and cannot be reverted.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be retrieved.
 @return ApiDeleteFooterCommentRequest
*/
func (a *CommentAPIService) DeleteFooterComment(ctx context.Context, commentId int64) ApiDeleteFooterCommentRequest {
	return ApiDeleteFooterCommentRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *CommentAPIService) DeleteFooterCommentExecute(r ApiDeleteFooterCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.DeleteFooterComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInlineCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
}

func (r ApiDeleteInlineCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInlineCommentExecute(r)
}

/*
DeleteInlineComment Delete inline comment

Deletes an inline comment. This is a permanent deletion and cannot be reverted.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be deleted.
 @return ApiDeleteInlineCommentRequest
*/
func (a *CommentAPIService) DeleteInlineComment(ctx context.Context, commentId int64) ApiDeleteInlineCommentRequest {
	return ApiDeleteInlineCommentRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *CommentAPIService) DeleteInlineCommentExecute(r ApiDeleteInlineCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.DeleteInlineComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAttachmentCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id string
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *CommentSortOrder
	version *int64
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetAttachmentCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetAttachmentCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetAttachmentCommentsRequest) Cursor(cursor string) ApiGetAttachmentCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetAttachmentCommentsRequest) Limit(limit int32) ApiGetAttachmentCommentsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetAttachmentCommentsRequest) Sort(sort CommentSortOrder) ApiGetAttachmentCommentsRequest {
	r.sort = &sort
	return r
}

// Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version.
func (r ApiGetAttachmentCommentsRequest) Version(version int64) ApiGetAttachmentCommentsRequest {
	r.version = &version
	return r
}

func (r ApiGetAttachmentCommentsRequest) Execute() (*MultiEntityResultAttachmentCommentModel, *http.Response, error) {
	return r.ApiService.GetAttachmentCommentsExecute(r)
}

/*
GetAttachmentComments Get attachment comments

Returns the comments of the specific attachment.
The number of results is limited by the `limit` parameter and additional results (if available) will be available through
the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the attachment and its corresponding containers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the attachment for which comments should be returned.
 @return ApiGetAttachmentCommentsRequest
*/
func (a *CommentAPIService) GetAttachmentComments(ctx context.Context, id string) ApiGetAttachmentCommentsRequest {
	return ApiGetAttachmentCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultAttachmentCommentModel
func (a *CommentAPIService) GetAttachmentCommentsExecute(r ApiGetAttachmentCommentsRequest) (*MultiEntityResultAttachmentCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultAttachmentCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetAttachmentComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostFooterCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	status *[]string
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostFooterCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostFooterCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Filter the footer comment being retrieved by its status.
func (r ApiGetBlogPostFooterCommentsRequest) Status(status []string) ApiGetBlogPostFooterCommentsRequest {
	r.status = &status
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostFooterCommentsRequest) Sort(sort CommentSortOrder) ApiGetBlogPostFooterCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostFooterCommentsRequest) Cursor(cursor string) ApiGetBlogPostFooterCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostFooterCommentsRequest) Limit(limit int32) ApiGetBlogPostFooterCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogPostFooterCommentsRequest) Execute() (*MultiEntityResultBlogPostCommentModel, *http.Response, error) {
	return r.ApiService.GetBlogPostFooterCommentsExecute(r)
}

/*
GetBlogPostFooterComments Get footer comments for blog post

Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post for which footer comments should be returned.
 @return ApiGetBlogPostFooterCommentsRequest
*/
func (a *CommentAPIService) GetBlogPostFooterComments(ctx context.Context, id int64) ApiGetBlogPostFooterCommentsRequest {
	return ApiGetBlogPostFooterCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultBlogPostCommentModel
func (a *CommentAPIService) GetBlogPostFooterCommentsExecute(r ApiGetBlogPostFooterCommentsRequest) (*MultiEntityResultBlogPostCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultBlogPostCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetBlogPostFooterComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostInlineCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	status *[]string
	resolutionStatus *[]string
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostInlineCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostInlineCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Filter the inline comment being retrieved by its status.
func (r ApiGetBlogPostInlineCommentsRequest) Status(status []string) ApiGetBlogPostInlineCommentsRequest {
	r.status = &status
	return r
}

// Filter the inline comment being retrieved by its resolution status.
func (r ApiGetBlogPostInlineCommentsRequest) ResolutionStatus(resolutionStatus []string) ApiGetBlogPostInlineCommentsRequest {
	r.resolutionStatus = &resolutionStatus
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostInlineCommentsRequest) Sort(sort CommentSortOrder) ApiGetBlogPostInlineCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostInlineCommentsRequest) Cursor(cursor string) ApiGetBlogPostInlineCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostInlineCommentsRequest) Limit(limit int32) ApiGetBlogPostInlineCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogPostInlineCommentsRequest) Execute() (*MultiEntityResultBlogPostInlineCommentModel, *http.Response, error) {
	return r.ApiService.GetBlogPostInlineCommentsExecute(r)
}

/*
GetBlogPostInlineComments Get inline comments for blog post

Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post for which inline comments should be returned.
 @return ApiGetBlogPostInlineCommentsRequest
*/
func (a *CommentAPIService) GetBlogPostInlineComments(ctx context.Context, id int64) ApiGetBlogPostInlineCommentsRequest {
	return ApiGetBlogPostInlineCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultBlogPostInlineCommentModel
func (a *CommentAPIService) GetBlogPostInlineCommentsExecute(r ApiGetBlogPostInlineCommentsRequest) (*MultiEntityResultBlogPostInlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultBlogPostInlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetBlogPostInlineComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/inline-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.resolutionStatus != nil {
		t := *r.resolutionStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resolution-status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resolution-status", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *CommentSortOrder
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetCustomContentCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetCustomContentCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentCommentsRequest) Cursor(cursor string) ApiGetCustomContentCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentCommentsRequest) Limit(limit int32) ApiGetCustomContentCommentsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentCommentsRequest) Sort(sort CommentSortOrder) ApiGetCustomContentCommentsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCustomContentCommentsRequest) Execute() (*MultiEntityResultCustomContentCommentModel, *http.Response, error) {
	return r.ApiService.GetCustomContentCommentsExecute(r)
}

/*
GetCustomContentComments Get custom content comments

Returns the comments of the specific custom content.
The number of results is limited by the `limit` parameter and additional results (if available) will be available through
the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content and its corresponding containers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom content for which comments should be returned.
 @return ApiGetCustomContentCommentsRequest
*/
func (a *CommentAPIService) GetCustomContentComments(ctx context.Context, id int64) ApiGetCustomContentCommentsRequest {
	return ApiGetCustomContentCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultCustomContentCommentModel
func (a *CommentAPIService) GetCustomContentCommentsExecute(r ApiGetCustomContentCommentsRequest) (*MultiEntityResultCustomContentCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultCustomContentCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetCustomContentComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentByIdRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
	bodyFormat *PrimaryBodyRepresentationSingle
	version *int32
	includeProperties *bool
	includeOperations *bool
	includeLikes *bool
	includeVersions *bool
	includeVersion *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentationSingle) ApiGetFooterCommentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetFooterCommentByIdRequest) Version(version int32) ApiGetFooterCommentByIdRequest {
	r.version = &version
	return r
}

// Includes content properties associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetFooterCommentByIdRequest) IncludeProperties(includeProperties bool) ApiGetFooterCommentByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes operations associated with this footer comment in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetFooterCommentByIdRequest) IncludeOperations(includeOperations bool) ApiGetFooterCommentByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes likes associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetFooterCommentByIdRequest) IncludeLikes(includeLikes bool) ApiGetFooterCommentByIdRequest {
	r.includeLikes = &includeLikes
	return r
}

// Includes versions associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetFooterCommentByIdRequest) IncludeVersions(includeVersions bool) ApiGetFooterCommentByIdRequest {
	r.includeVersions = &includeVersions
	return r
}

// Includes the current version associated with this footer comment in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
func (r ApiGetFooterCommentByIdRequest) IncludeVersion(includeVersion bool) ApiGetFooterCommentByIdRequest {
	r.includeVersion = &includeVersion
	return r
}

func (r ApiGetFooterCommentByIdRequest) Execute() (*CreateFooterComment201Response, *http.Response, error) {
	return r.ApiService.GetFooterCommentByIdExecute(r)
}

/*
GetFooterCommentById Get footer comment by id

Retrieves a footer comment by id

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the container and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be retrieved.
 @return ApiGetFooterCommentByIdRequest
*/
func (a *CommentAPIService) GetFooterCommentById(ctx context.Context, commentId int64) ApiGetFooterCommentByIdRequest {
	return ApiGetFooterCommentByIdRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return CreateFooterComment201Response
func (a *CommentAPIService) GetFooterCommentByIdExecute(r ApiGetFooterCommentByIdRequest) (*CreateFooterComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFooterComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetFooterCommentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeLikes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", r.includeLikes, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", defaultValue, "form", "")
		r.includeLikes = &defaultValue
	}
	if r.includeVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", r.includeVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", defaultValue, "form", "")
		r.includeVersions = &defaultValue
	}
	if r.includeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", r.includeVersion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", defaultValue, "form", "")
		r.includeVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentChildrenRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentChildrenRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetFooterCommentChildrenRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetFooterCommentChildrenRequest) Sort(sort CommentSortOrder) ApiGetFooterCommentChildrenRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetFooterCommentChildrenRequest) Cursor(cursor string) ApiGetFooterCommentChildrenRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetFooterCommentChildrenRequest) Limit(limit int32) ApiGetFooterCommentChildrenRequest {
	r.limit = &limit
	return r
}

func (r ApiGetFooterCommentChildrenRequest) Execute() (*MultiEntityResultChildrenCommentModel, *http.Response, error) {
	return r.ApiService.GetFooterCommentChildrenExecute(r)
}

/*
GetFooterCommentChildren Get children footer comments

Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the parent comment for which footer comment children should be returned.
 @return ApiGetFooterCommentChildrenRequest
*/
func (a *CommentAPIService) GetFooterCommentChildren(ctx context.Context, id int64) ApiGetFooterCommentChildrenRequest {
	return ApiGetFooterCommentChildrenRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultChildrenCommentModel
func (a *CommentAPIService) GetFooterCommentChildrenExecute(r ApiGetFooterCommentChildrenRequest) (*MultiEntityResultChildrenCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultChildrenCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetFooterCommentChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	bodyFormat *PrimaryBodyRepresentation
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetFooterCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetFooterCommentsRequest) Sort(sort CommentSortOrder) ApiGetFooterCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetFooterCommentsRequest) Cursor(cursor string) ApiGetFooterCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetFooterCommentsRequest) Limit(limit int32) ApiGetFooterCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetFooterCommentsRequest) Execute() (*MultiEntityResultFooterCommentModel, *http.Response, error) {
	return r.ApiService.GetFooterCommentsExecute(r)
}

/*
GetFooterComments Get footer comments

Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the container and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFooterCommentsRequest
*/
func (a *CommentAPIService) GetFooterComments(ctx context.Context) ApiGetFooterCommentsRequest {
	return ApiGetFooterCommentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultFooterCommentModel
func (a *CommentAPIService) GetFooterCommentsExecute(r ApiGetFooterCommentsRequest) (*MultiEntityResultFooterCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultFooterCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetFooterComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentByIdRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
	bodyFormat *PrimaryBodyRepresentationSingle
	version *int32
	includeProperties *bool
	includeOperations *bool
	includeLikes *bool
	includeVersions *bool
	includeVersion *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentationSingle) ApiGetInlineCommentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetInlineCommentByIdRequest) Version(version int32) ApiGetInlineCommentByIdRequest {
	r.version = &version
	return r
}

// Includes content properties associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetInlineCommentByIdRequest) IncludeProperties(includeProperties bool) ApiGetInlineCommentByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes operations associated with this inline comment in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetInlineCommentByIdRequest) IncludeOperations(includeOperations bool) ApiGetInlineCommentByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes likes associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetInlineCommentByIdRequest) IncludeLikes(includeLikes bool) ApiGetInlineCommentByIdRequest {
	r.includeLikes = &includeLikes
	return r
}

// Includes versions associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetInlineCommentByIdRequest) IncludeVersions(includeVersions bool) ApiGetInlineCommentByIdRequest {
	r.includeVersions = &includeVersions
	return r
}

// Includes the current version associated with this inline comment in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
func (r ApiGetInlineCommentByIdRequest) IncludeVersion(includeVersion bool) ApiGetInlineCommentByIdRequest {
	r.includeVersion = &includeVersion
	return r
}

func (r ApiGetInlineCommentByIdRequest) Execute() (*CreateInlineComment201Response, *http.Response, error) {
	return r.ApiService.GetInlineCommentByIdExecute(r)
}

/*
GetInlineCommentById Get inline comment by id

Retrieves an inline comment by id

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be retrieved.
 @return ApiGetInlineCommentByIdRequest
*/
func (a *CommentAPIService) GetInlineCommentById(ctx context.Context, commentId int64) ApiGetInlineCommentByIdRequest {
	return ApiGetInlineCommentByIdRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return CreateInlineComment201Response
func (a *CommentAPIService) GetInlineCommentByIdExecute(r ApiGetInlineCommentByIdRequest) (*CreateInlineComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateInlineComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetInlineCommentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeLikes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", r.includeLikes, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", defaultValue, "form", "")
		r.includeLikes = &defaultValue
	}
	if r.includeVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", r.includeVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", defaultValue, "form", "")
		r.includeVersions = &defaultValue
	}
	if r.includeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", r.includeVersion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", defaultValue, "form", "")
		r.includeVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentChildrenRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentChildrenRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetInlineCommentChildrenRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetInlineCommentChildrenRequest) Sort(sort CommentSortOrder) ApiGetInlineCommentChildrenRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetInlineCommentChildrenRequest) Cursor(cursor string) ApiGetInlineCommentChildrenRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetInlineCommentChildrenRequest) Limit(limit int32) ApiGetInlineCommentChildrenRequest {
	r.limit = &limit
	return r
}

func (r ApiGetInlineCommentChildrenRequest) Execute() (*MultiEntityResultInlineCommentChildrenModel, *http.Response, error) {
	return r.ApiService.GetInlineCommentChildrenExecute(r)
}

/*
GetInlineCommentChildren Get children inline comments

Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the parent comment for which inline comment children should be returned.
 @return ApiGetInlineCommentChildrenRequest
*/
func (a *CommentAPIService) GetInlineCommentChildren(ctx context.Context, id int64) ApiGetInlineCommentChildrenRequest {
	return ApiGetInlineCommentChildrenRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultInlineCommentChildrenModel
func (a *CommentAPIService) GetInlineCommentChildrenExecute(r ApiGetInlineCommentChildrenRequest) (*MultiEntityResultInlineCommentChildrenModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultInlineCommentChildrenModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetInlineCommentChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	bodyFormat *PrimaryBodyRepresentation
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetInlineCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetInlineCommentsRequest) Sort(sort CommentSortOrder) ApiGetInlineCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetInlineCommentsRequest) Cursor(cursor string) ApiGetInlineCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetInlineCommentsRequest) Limit(limit int32) ApiGetInlineCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetInlineCommentsRequest) Execute() (*MultiEntityResultInlineCommentModel, *http.Response, error) {
	return r.ApiService.GetInlineCommentsExecute(r)
}

/*
GetInlineComments Get inline comments

Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInlineCommentsRequest
*/
func (a *CommentAPIService) GetInlineComments(ctx context.Context) ApiGetInlineCommentsRequest {
	return ApiGetInlineCommentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultInlineCommentModel
func (a *CommentAPIService) GetInlineCommentsExecute(r ApiGetInlineCommentsRequest) (*MultiEntityResultInlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultInlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetInlineComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageFooterCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	status *[]string
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageFooterCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageFooterCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Filter the footer comment being retrieved by its status.
func (r ApiGetPageFooterCommentsRequest) Status(status []string) ApiGetPageFooterCommentsRequest {
	r.status = &status
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageFooterCommentsRequest) Sort(sort CommentSortOrder) ApiGetPageFooterCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageFooterCommentsRequest) Cursor(cursor string) ApiGetPageFooterCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageFooterCommentsRequest) Limit(limit int32) ApiGetPageFooterCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPageFooterCommentsRequest) Execute() (*MultiEntityResultPageCommentModel, *http.Response, error) {
	return r.ApiService.GetPageFooterCommentsExecute(r)
}

/*
GetPageFooterComments Get footer comments for page

Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page for which footer comments should be returned.
 @return ApiGetPageFooterCommentsRequest
*/
func (a *CommentAPIService) GetPageFooterComments(ctx context.Context, id int64) ApiGetPageFooterCommentsRequest {
	return ApiGetPageFooterCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultPageCommentModel
func (a *CommentAPIService) GetPageFooterCommentsExecute(r ApiGetPageFooterCommentsRequest) (*MultiEntityResultPageCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultPageCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetPageFooterComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageInlineCommentsRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	status *[]string
	resolutionStatus *[]string
	sort *CommentSortOrder
	cursor *string
	limit *int32
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageInlineCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageInlineCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Filter the inline comment being retrieved by its status.
func (r ApiGetPageInlineCommentsRequest) Status(status []string) ApiGetPageInlineCommentsRequest {
	r.status = &status
	return r
}

// Filter the inline comment being retrieved by its resolution status.
func (r ApiGetPageInlineCommentsRequest) ResolutionStatus(resolutionStatus []string) ApiGetPageInlineCommentsRequest {
	r.resolutionStatus = &resolutionStatus
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageInlineCommentsRequest) Sort(sort CommentSortOrder) ApiGetPageInlineCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageInlineCommentsRequest) Cursor(cursor string) ApiGetPageInlineCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageInlineCommentsRequest) Limit(limit int32) ApiGetPageInlineCommentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPageInlineCommentsRequest) Execute() (*MultiEntityResultPageInlineCommentModel, *http.Response, error) {
	return r.ApiService.GetPageInlineCommentsExecute(r)
}

/*
GetPageInlineComments Get inline comments for page

Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page for which inline comments should be returned.
 @return ApiGetPageInlineCommentsRequest
*/
func (a *CommentAPIService) GetPageInlineComments(ctx context.Context, id int64) ApiGetPageInlineCommentsRequest {
	return ApiGetPageInlineCommentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultPageInlineCommentModel
func (a *CommentAPIService) GetPageInlineCommentsExecute(r ApiGetPageInlineCommentsRequest) (*MultiEntityResultPageInlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultPageInlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.GetPageInlineComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/inline-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.resolutionStatus != nil {
		t := *r.resolutionStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resolution-status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resolution-status", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFooterCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
	updateFooterCommentRequest *UpdateFooterCommentRequest
}

// The footer comment to be created
func (r ApiUpdateFooterCommentRequest) UpdateFooterCommentRequest(updateFooterCommentRequest UpdateFooterCommentRequest) ApiUpdateFooterCommentRequest {
	r.updateFooterCommentRequest = &updateFooterCommentRequest
	return r
}

func (r ApiUpdateFooterCommentRequest) Execute() (*FooterCommentModel, *http.Response, error) {
	return r.ApiService.UpdateFooterCommentExecute(r)
}

/*
UpdateFooterComment Update footer comment

Update a footer comment. This can be used to update the body text of a comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be retrieved.
 @return ApiUpdateFooterCommentRequest
*/
func (a *CommentAPIService) UpdateFooterComment(ctx context.Context, commentId int64) ApiUpdateFooterCommentRequest {
	return ApiUpdateFooterCommentRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return FooterCommentModel
func (a *CommentAPIService) UpdateFooterCommentExecute(r ApiUpdateFooterCommentRequest) (*FooterCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FooterCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.UpdateFooterComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFooterCommentRequest == nil {
		return localVarReturnValue, nil, reportError("updateFooterCommentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFooterCommentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInlineCommentRequest struct {
	ctx context.Context
	ApiService *CommentAPIService
	commentId int64
	updateInlineCommentModel *UpdateInlineCommentModel
}

// The inline comment to be updated
func (r ApiUpdateInlineCommentRequest) UpdateInlineCommentModel(updateInlineCommentModel UpdateInlineCommentModel) ApiUpdateInlineCommentRequest {
	r.updateInlineCommentModel = &updateInlineCommentModel
	return r
}

func (r ApiUpdateInlineCommentRequest) Execute() (*CreateInlineComment201Response, *http.Response, error) {
	return r.ApiService.UpdateInlineCommentExecute(r)
}

/*
UpdateInlineComment Update inline comment

Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId The ID of the comment to be retrieved.
 @return ApiUpdateInlineCommentRequest
*/
func (a *CommentAPIService) UpdateInlineComment(ctx context.Context, commentId int64) ApiUpdateInlineCommentRequest {
	return ApiUpdateInlineCommentRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return CreateInlineComment201Response
func (a *CommentAPIService) UpdateInlineCommentExecute(r ApiUpdateInlineCommentRequest) (*CreateInlineComment201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateInlineComment201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentAPIService.UpdateInlineComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateInlineCommentModel == nil {
		return localVarReturnValue, nil, reportError("updateInlineCommentModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInlineCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

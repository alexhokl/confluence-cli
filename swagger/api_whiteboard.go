/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// WhiteboardAPIService WhiteboardAPI service
type WhiteboardAPIService service

type ApiCreateWhiteboardRequest struct {
	ctx context.Context
	ApiService *WhiteboardAPIService
	createWhiteboardRequest *CreateWhiteboardRequest
	private *bool
}

func (r ApiCreateWhiteboardRequest) CreateWhiteboardRequest(createWhiteboardRequest CreateWhiteboardRequest) ApiCreateWhiteboardRequest {
	r.createWhiteboardRequest = &createWhiteboardRequest
	return r
}

// The whiteboard will be private. Only the user who creates this whiteboard will have permission to view and edit one.
func (r ApiCreateWhiteboardRequest) Private(private bool) ApiCreateWhiteboardRequest {
	r.private = &private
	return r
}

func (r ApiCreateWhiteboardRequest) Execute() (*CreateWhiteboard200Response, *http.Response, error) {
	return r.ApiService.CreateWhiteboardExecute(r)
}

/*
CreateWhiteboard Create whiteboard

Creates a whiteboard in the space.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the corresponding space. Permission to create a whiteboard in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWhiteboardRequest
*/
func (a *WhiteboardAPIService) CreateWhiteboard(ctx context.Context) ApiCreateWhiteboardRequest {
	return ApiCreateWhiteboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWhiteboard200Response
func (a *WhiteboardAPIService) CreateWhiteboardExecute(r ApiCreateWhiteboardRequest) (*CreateWhiteboard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWhiteboard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhiteboardAPIService.CreateWhiteboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createWhiteboardRequest == nil {
		return localVarReturnValue, nil, reportError("createWhiteboardRequest is required and must be specified")
	}

	if r.private != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", r.private, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", defaultValue, "form", "")
		r.private = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createWhiteboardRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWhiteboardRequest struct {
	ctx context.Context
	ApiService *WhiteboardAPIService
	id int64
}

func (r ApiDeleteWhiteboardRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWhiteboardExecute(r)
}

/*
DeleteWhiteboard Delete whiteboard

Delete a whiteboard by id.

Deleting a whiteboard moves the whiteboard to the trash, where it can be restored later

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the whiteboard and its corresponding space.
Permission to delete whiteboards in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the whiteboard to be deleted.
 @return ApiDeleteWhiteboardRequest
*/
func (a *WhiteboardAPIService) DeleteWhiteboard(ctx context.Context, id int64) ApiDeleteWhiteboardRequest {
	return ApiDeleteWhiteboardRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *WhiteboardAPIService) DeleteWhiteboardExecute(r ApiDeleteWhiteboardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhiteboardAPIService.DeleteWhiteboard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetWhiteboardByIdRequest struct {
	ctx context.Context
	ApiService *WhiteboardAPIService
	id int64
	includeCollaborators *bool
	includeDirectChildren *bool
	includeOperations *bool
	includeProperties *bool
}

// Includes collaborators on the whiteboard.
func (r ApiGetWhiteboardByIdRequest) IncludeCollaborators(includeCollaborators bool) ApiGetWhiteboardByIdRequest {
	r.includeCollaborators = &includeCollaborators
	return r
}

// Includes direct children of the whiteboard, as defined in the &#x60;ChildrenResponse&#x60; object.
func (r ApiGetWhiteboardByIdRequest) IncludeDirectChildren(includeDirectChildren bool) ApiGetWhiteboardByIdRequest {
	r.includeDirectChildren = &includeDirectChildren
	return r
}

// Includes operations associated with this whiteboard in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetWhiteboardByIdRequest) IncludeOperations(includeOperations bool) ApiGetWhiteboardByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes content properties associated with this whiteboard in the response. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetWhiteboardByIdRequest) IncludeProperties(includeProperties bool) ApiGetWhiteboardByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

func (r ApiGetWhiteboardByIdRequest) Execute() (*CreateWhiteboard200Response, *http.Response, error) {
	return r.ApiService.GetWhiteboardByIdExecute(r)
}

/*
GetWhiteboardById Get whiteboard by id

Returns a specific whiteboard.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the whiteboard and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the whiteboard to be returned
 @return ApiGetWhiteboardByIdRequest
*/
func (a *WhiteboardAPIService) GetWhiteboardById(ctx context.Context, id int64) ApiGetWhiteboardByIdRequest {
	return ApiGetWhiteboardByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateWhiteboard200Response
func (a *WhiteboardAPIService) GetWhiteboardByIdExecute(r ApiGetWhiteboardByIdRequest) (*CreateWhiteboard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWhiteboard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WhiteboardAPIService.GetWhiteboardById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whiteboards/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeCollaborators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", r.includeCollaborators, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", defaultValue, "form", "")
		r.includeCollaborators = &defaultValue
	}
	if r.includeDirectChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-direct-children", r.includeDirectChildren, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-direct-children", defaultValue, "form", "")
		r.includeDirectChildren = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

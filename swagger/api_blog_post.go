/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BlogPostAPIService BlogPostAPI service
type BlogPostAPIService service

type ApiCreateBlogPostRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	createBlogPostRequest *CreateBlogPostRequest
	private *bool
}

func (r ApiCreateBlogPostRequest) CreateBlogPostRequest(createBlogPostRequest CreateBlogPostRequest) ApiCreateBlogPostRequest {
	r.createBlogPostRequest = &createBlogPostRequest
	return r
}

// The blog post will be private. Only the user who creates this blog post will have permission to view and edit one.
func (r ApiCreateBlogPostRequest) Private(private bool) ApiCreateBlogPostRequest {
	r.private = &private
	return r
}

func (r ApiCreateBlogPostRequest) Execute() (*CreateBlogPost200Response, *http.Response, error) {
	return r.ApiService.CreateBlogPostExecute(r)
}

/*
CreateBlogPost Create blog post

Creates a new blog post in the space specified by the spaceId.

By default this will create the blog post as a non-draft, unless the status is specified as draft.
If creating a non-draft, the title must not be empty.

Currently only supports the storage representation specified in the body.representation enums below

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBlogPostRequest
*/
func (a *BlogPostAPIService) CreateBlogPost(ctx context.Context) ApiCreateBlogPostRequest {
	return ApiCreateBlogPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBlogPost200Response
func (a *BlogPostAPIService) CreateBlogPostExecute(r ApiCreateBlogPostRequest) (*CreateBlogPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBlogPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.CreateBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBlogPostRequest == nil {
		return localVarReturnValue, nil, reportError("createBlogPostRequest is required and must be specified")
	}

	if r.private != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", r.private, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "private", defaultValue, "form", "")
		r.private = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBlogPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlogPostRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id int64
	purge *bool
	draft *bool
}

// If attempting to purge the blog post.
func (r ApiDeleteBlogPostRequest) Purge(purge bool) ApiDeleteBlogPostRequest {
	r.purge = &purge
	return r
}

// If attempting to delete a blog post that is a draft.
func (r ApiDeleteBlogPostRequest) Draft(draft bool) ApiDeleteBlogPostRequest {
	r.draft = &draft
	return r
}

func (r ApiDeleteBlogPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBlogPostExecute(r)
}

/*
DeleteBlogPost Delete blog post

Delete a blog post by id.

By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a 
draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.

Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later.
To permanently delete a blog post (or "purge" it), the endpoint must be called on a **trashed** blog post with the following param `purge=true`.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space.
Permission to delete blog posts in the space.
Permission to administer the space (if attempting to purge).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post to be deleted.
 @return ApiDeleteBlogPostRequest
*/
func (a *BlogPostAPIService) DeleteBlogPost(ctx context.Context, id int64) ApiDeleteBlogPostRequest {
	return ApiDeleteBlogPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BlogPostAPIService) DeleteBlogPostExecute(r ApiDeleteBlogPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.DeleteBlogPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", defaultValue, "form", "")
		r.purge = &defaultValue
	}
	if r.draft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "draft", r.draft, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "draft", defaultValue, "form", "")
		r.draft = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBlogPostByIdRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentationSingle
	getDraft *bool
	status *[]string
	version *int32
	includeLabels *bool
	includeProperties *bool
	includeOperations *bool
	includeLikes *bool
	includeVersions *bool
	includeVersion *bool
	includeFavoritedByCurrentUserStatus *bool
	includeWebresources *bool
	includeCollaborators *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentationSingle) ApiGetBlogPostByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Retrieve the draft version of this blog post.
func (r ApiGetBlogPostByIdRequest) GetDraft(getDraft bool) ApiGetBlogPostByIdRequest {
	r.getDraft = &getDraft
	return r
}

// Filter the blog post being retrieved by its status.
func (r ApiGetBlogPostByIdRequest) Status(status []string) ApiGetBlogPostByIdRequest {
	r.status = &status
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetBlogPostByIdRequest) Version(version int32) ApiGetBlogPostByIdRequest {
	r.version = &version
	return r
}

// Includes labels associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetBlogPostByIdRequest) IncludeLabels(includeLabels bool) ApiGetBlogPostByIdRequest {
	r.includeLabels = &includeLabels
	return r
}

// Includes content properties associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetBlogPostByIdRequest) IncludeProperties(includeProperties bool) ApiGetBlogPostByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes operations associated with this blog post in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetBlogPostByIdRequest) IncludeOperations(includeOperations bool) ApiGetBlogPostByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes likes associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetBlogPostByIdRequest) IncludeLikes(includeLikes bool) ApiGetBlogPostByIdRequest {
	r.includeLikes = &includeLikes
	return r
}

// Includes versions associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetBlogPostByIdRequest) IncludeVersions(includeVersions bool) ApiGetBlogPostByIdRequest {
	r.includeVersions = &includeVersions
	return r
}

// Includes the current version associated with this blog post in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
func (r ApiGetBlogPostByIdRequest) IncludeVersion(includeVersion bool) ApiGetBlogPostByIdRequest {
	r.includeVersion = &includeVersion
	return r
}

// Includes whether this blog post has been favorited by the current user.
func (r ApiGetBlogPostByIdRequest) IncludeFavoritedByCurrentUserStatus(includeFavoritedByCurrentUserStatus bool) ApiGetBlogPostByIdRequest {
	r.includeFavoritedByCurrentUserStatus = &includeFavoritedByCurrentUserStatus
	return r
}

// Includes web resources that can be used to render blog post content on a client.
func (r ApiGetBlogPostByIdRequest) IncludeWebresources(includeWebresources bool) ApiGetBlogPostByIdRequest {
	r.includeWebresources = &includeWebresources
	return r
}

// Includes collaborators on the blog post.
func (r ApiGetBlogPostByIdRequest) IncludeCollaborators(includeCollaborators bool) ApiGetBlogPostByIdRequest {
	r.includeCollaborators = &includeCollaborators
	return r
}

func (r ApiGetBlogPostByIdRequest) Execute() (*CreateBlogPost200Response, *http.Response, error) {
	return r.ApiService.GetBlogPostByIdExecute(r)
}

/*
GetBlogPostById Get blog post by id

Returns a specific blog post.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results.
 @return ApiGetBlogPostByIdRequest
*/
func (a *BlogPostAPIService) GetBlogPostById(ctx context.Context, id int64) ApiGetBlogPostByIdRequest {
	return ApiGetBlogPostByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateBlogPost200Response
func (a *BlogPostAPIService) GetBlogPostByIdExecute(r ApiGetBlogPostByIdRequest) (*CreateBlogPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBlogPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.GetBlogPostById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.getDraft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", r.getDraft, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", defaultValue, "form", "")
		r.getDraft = &defaultValue
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", r.includeLabels, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", defaultValue, "form", "")
		r.includeLabels = &defaultValue
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeLikes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", r.includeLikes, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-likes", defaultValue, "form", "")
		r.includeLikes = &defaultValue
	}
	if r.includeVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", r.includeVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", defaultValue, "form", "")
		r.includeVersions = &defaultValue
	}
	if r.includeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", r.includeVersion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", defaultValue, "form", "")
		r.includeVersion = &defaultValue
	}
	if r.includeFavoritedByCurrentUserStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-favorited-by-current-user-status", r.includeFavoritedByCurrentUserStatus, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-favorited-by-current-user-status", defaultValue, "form", "")
		r.includeFavoritedByCurrentUserStatus = &defaultValue
	}
	if r.includeWebresources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-webresources", r.includeWebresources, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-webresources", defaultValue, "form", "")
		r.includeWebresources = &defaultValue
	}
	if r.includeCollaborators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", r.includeCollaborators, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", defaultValue, "form", "")
		r.includeCollaborators = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostsRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id *[]int64
	spaceId *[]int64
	sort *BlogPostSortOrder
	status *[]string
	title *string
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
}

// Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.
func (r ApiGetBlogPostsRequest) Id(id []int64) ApiGetBlogPostsRequest {
	r.id = &id
	return r
}

// Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
func (r ApiGetBlogPostsRequest) SpaceId(spaceId []int64) ApiGetBlogPostsRequest {
	r.spaceId = &spaceId
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostsRequest) Sort(sort BlogPostSortOrder) ApiGetBlogPostsRequest {
	r.sort = &sort
	return r
}

// Filter the results to blog posts based on their status. By default, &#x60;current&#x60; is used.
func (r ApiGetBlogPostsRequest) Status(status []string) ApiGetBlogPostsRequest {
	r.status = &status
	return r
}

// Filter the results to blog posts based on their title.
func (r ApiGetBlogPostsRequest) Title(title string) ApiGetBlogPostsRequest {
	r.title = &title
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostsRequest) Cursor(cursor string) ApiGetBlogPostsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostsRequest) Limit(limit int32) ApiGetBlogPostsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogPostsRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetBlogPostsExecute(r)
}

/*
GetBlogPosts Get blog posts

Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only blog posts that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlogPostsRequest
*/
func (a *BlogPostAPIService) GetBlogPosts(ctx context.Context) ApiGetBlogPostsRequest {
	return ApiGetBlogPostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultBlogPost
func (a *BlogPostAPIService) GetBlogPostsExecute(r ApiGetBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.GetBlogPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostsInSpaceRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id int64
	sort *BlogPostSortOrder
	status *[]string
	title *string
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostsInSpaceRequest) Sort(sort BlogPostSortOrder) ApiGetBlogPostsInSpaceRequest {
	r.sort = &sort
	return r
}

// Filter the results to blog posts based on their status. By default, &#x60;current&#x60; is used.
func (r ApiGetBlogPostsInSpaceRequest) Status(status []string) ApiGetBlogPostsInSpaceRequest {
	r.status = &status
	return r
}

// Filter the results to blog posts based on their title.
func (r ApiGetBlogPostsInSpaceRequest) Title(title string) ApiGetBlogPostsInSpaceRequest {
	r.title = &title
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostsInSpaceRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostsInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostsInSpaceRequest) Cursor(cursor string) ApiGetBlogPostsInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostsInSpaceRequest) Limit(limit int32) ApiGetBlogPostsInSpaceRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogPostsInSpaceRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetBlogPostsInSpaceExecute(r)
}

/*
GetBlogPostsInSpace Get blog posts in space

Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission) and view the space.
Only blog posts that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which blog posts should be returned.
 @return ApiGetBlogPostsInSpaceRequest
*/
func (a *BlogPostAPIService) GetBlogPostsInSpace(ctx context.Context, id int64) ApiGetBlogPostsInSpaceRequest {
	return ApiGetBlogPostsInSpaceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultBlogPost
func (a *BlogPostAPIService) GetBlogPostsInSpaceExecute(r ApiGetBlogPostsInSpaceRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.GetBlogPostsInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/blogposts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLabelBlogPostsRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id int64
	spaceId *[]int64
	bodyFormat *PrimaryBodyRepresentation
	sort *BlogPostSortOrder
	cursor *string
	limit *int32
}

// Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
func (r ApiGetLabelBlogPostsRequest) SpaceId(spaceId []int64) ApiGetLabelBlogPostsRequest {
	r.spaceId = &spaceId
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetLabelBlogPostsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetLabelBlogPostsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetLabelBlogPostsRequest) Sort(sort BlogPostSortOrder) ApiGetLabelBlogPostsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetLabelBlogPostsRequest) Cursor(cursor string) ApiGetLabelBlogPostsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetLabelBlogPostsRequest) Limit(limit int32) ApiGetLabelBlogPostsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetLabelBlogPostsRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetLabelBlogPostsExecute(r)
}

/*
GetLabelBlogPosts Get blog posts for label

Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the label for which blog posts should be returned.
 @return ApiGetLabelBlogPostsRequest
*/
func (a *BlogPostAPIService) GetLabelBlogPosts(ctx context.Context, id int64) ApiGetLabelBlogPostsRequest {
	return ApiGetLabelBlogPostsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultBlogPost
func (a *BlogPostAPIService) GetLabelBlogPostsExecute(r ApiGetLabelBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.GetLabelBlogPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/labels/{id}/blogposts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "form", "multi")
		}
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlogPostRequest struct {
	ctx context.Context
	ApiService *BlogPostAPIService
	id int64
	updateBlogPostRequest *UpdateBlogPostRequest
}

func (r ApiUpdateBlogPostRequest) UpdateBlogPostRequest(updateBlogPostRequest UpdateBlogPostRequest) ApiUpdateBlogPostRequest {
	r.updateBlogPostRequest = &updateBlogPostRequest
	return r
}

func (r ApiUpdateBlogPostRequest) Execute() (*CreateBlogPost200Response, *http.Response, error) {
	return r.ApiService.UpdateBlogPostExecute(r)
}

/*
UpdateBlogPost Update blog post

Update a blog post by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results.
 @return ApiUpdateBlogPostRequest
*/
func (a *BlogPostAPIService) UpdateBlogPost(ctx context.Context, id int64) ApiUpdateBlogPostRequest {
	return ApiUpdateBlogPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateBlogPost200Response
func (a *BlogPostAPIService) UpdateBlogPostExecute(r ApiUpdateBlogPostRequest) (*CreateBlogPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBlogPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostAPIService.UpdateBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateBlogPostRequest == nil {
		return localVarReturnValue, nil, reportError("updateBlogPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBlogPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

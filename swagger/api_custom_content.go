/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CustomContentAPIService CustomContentAPI service
type CustomContentAPIService service

type ApiCreateCustomContentRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	createCustomContentRequest *CreateCustomContentRequest
}

func (r ApiCreateCustomContentRequest) CreateCustomContentRequest(createCustomContentRequest CreateCustomContentRequest) ApiCreateCustomContentRequest {
	r.createCustomContentRequest = &createCustomContentRequest
	return r
}

func (r ApiCreateCustomContentRequest) Execute() (*CreateCustomContent201Response, *http.Response, error) {
	return r.ApiService.CreateCustomContentExecute(r)
}

/*
CreateCustomContent Create custom content

Creates a new custom content in the given space, page, blogpost or other custom content.

Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCustomContentRequest
*/
func (a *CustomContentAPIService) CreateCustomContent(ctx context.Context) ApiCreateCustomContentRequest {
	return ApiCreateCustomContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCustomContent201Response
func (a *CustomContentAPIService) CreateCustomContentExecute(r ApiCreateCustomContentRequest) (*CreateCustomContent201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCustomContent201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.CreateCustomContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCustomContentRequest == nil {
		return localVarReturnValue, nil, reportError("createCustomContentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCustomContentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCustomContentRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	purge *bool
}

// If attempting to purge the custom content.
func (r ApiDeleteCustomContentRequest) Purge(purge bool) ApiDeleteCustomContentRequest {
	r.purge = &purge
	return r
}

func (r ApiDeleteCustomContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomContentExecute(r)
}

/*
DeleteCustomContent Delete custom content

Delete a custom content by id.

Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport.
To permanently delete a **trashed** custom content, the endpoint must be called with the following param `purge=true`.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space.
Permission to delete custom content in the space.
Permission to administer the space (if attempting to purge).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom content to be deleted.
 @return ApiDeleteCustomContentRequest
*/
func (a *CustomContentAPIService) DeleteCustomContent(ctx context.Context, id int64) ApiDeleteCustomContentRequest {
	return ApiDeleteCustomContentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CustomContentAPIService) DeleteCustomContentExecute(r ApiDeleteCustomContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.DeleteCustomContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", defaultValue, "form", "")
		r.purge = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCustomContentByIdRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	bodyFormat *CustomContentBodyRepresentationSingle
	version *int32
	includeLabels *bool
	includeProperties *bool
	includeOperations *bool
	includeVersions *bool
	includeVersion *bool
	includeCollaborators *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByIdRequest) BodyFormat(bodyFormat CustomContentBodyRepresentationSingle) ApiGetCustomContentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetCustomContentByIdRequest) Version(version int32) ApiGetCustomContentByIdRequest {
	r.version = &version
	return r
}

// Includes labels associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetCustomContentByIdRequest) IncludeLabels(includeLabels bool) ApiGetCustomContentByIdRequest {
	r.includeLabels = &includeLabels
	return r
}

// Includes content properties associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetCustomContentByIdRequest) IncludeProperties(includeProperties bool) ApiGetCustomContentByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes operations associated with this custom content in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetCustomContentByIdRequest) IncludeOperations(includeOperations bool) ApiGetCustomContentByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes versions associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetCustomContentByIdRequest) IncludeVersions(includeVersions bool) ApiGetCustomContentByIdRequest {
	r.includeVersions = &includeVersions
	return r
}

// Includes the current version associated with this custom content in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
func (r ApiGetCustomContentByIdRequest) IncludeVersion(includeVersion bool) ApiGetCustomContentByIdRequest {
	r.includeVersion = &includeVersion
	return r
}

// Includes collaborators on the custom content.
func (r ApiGetCustomContentByIdRequest) IncludeCollaborators(includeCollaborators bool) ApiGetCustomContentByIdRequest {
	r.includeCollaborators = &includeCollaborators
	return r
}

func (r ApiGetCustomContentByIdRequest) Execute() (*CreateCustomContent201Response, *http.Response, error) {
	return r.ApiService.GetCustomContentByIdExecute(r)
}

/*
GetCustomContentById Get custom content by id

Returns a specific piece of custom content. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
 @return ApiGetCustomContentByIdRequest
*/
func (a *CustomContentAPIService) GetCustomContentById(ctx context.Context, id int64) ApiGetCustomContentByIdRequest {
	return ApiGetCustomContentByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateCustomContent201Response
func (a *CustomContentAPIService) GetCustomContentByIdExecute(r ApiGetCustomContentByIdRequest) (*CreateCustomContent201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCustomContent201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.GetCustomContentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", r.includeLabels, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", defaultValue, "form", "")
		r.includeLabels = &defaultValue
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", r.includeVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-versions", defaultValue, "form", "")
		r.includeVersions = &defaultValue
	}
	if r.includeVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", r.includeVersion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-version", defaultValue, "form", "")
		r.includeVersion = &defaultValue
	}
	if r.includeCollaborators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", r.includeCollaborators, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-collaborators", defaultValue, "form", "")
		r.includeCollaborators = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	type_ *string
	id *[]int64
	spaceId *[]int64
	sort *CustomContentSortOrder
	cursor *string
	limit *int32
	bodyFormat *CustomContentBodyRepresentation
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeRequest) Type_(type_ string) ApiGetCustomContentByTypeRequest {
	r.type_ = &type_
	return r
}

// Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.
func (r ApiGetCustomContentByTypeRequest) Id(id []int64) ApiGetCustomContentByTypeRequest {
	r.id = &id
	return r
}

// Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
func (r ApiGetCustomContentByTypeRequest) SpaceId(spaceId []int64) ApiGetCustomContentByTypeRequest {
	r.spaceId = &spaceId
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentByTypeRequest) Sort(sort CustomContentSortOrder) ApiGetCustomContentByTypeRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeRequest) Cursor(cursor string) ApiGetCustomContentByTypeRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeRequest) Limit(limit int32) ApiGetCustomContentByTypeRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeRequest {
	r.bodyFormat = &bodyFormat
	return r
}

func (r ApiGetCustomContentByTypeRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeExecute(r)
}

/*
GetCustomContentByType Get custom content by type

Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCustomContentByTypeRequest
*/
func (a *CustomContentAPIService) GetCustomContentByType(ctx context.Context) ApiGetCustomContentByTypeRequest {
	return ApiGetCustomContentByTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultCustomContent
func (a *CustomContentAPIService) GetCustomContentByTypeExecute(r ApiGetCustomContentByTypeRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.GetCustomContentByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInBlogPostRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	type_ *string
	sort *CustomContentSortOrder
	cursor *string
	limit *int32
	bodyFormat *CustomContentBodyRepresentation
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Type_(type_ string) ApiGetCustomContentByTypeInBlogPostRequest {
	r.type_ = &type_
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Sort(sort CustomContentSortOrder) ApiGetCustomContentByTypeInBlogPostRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Cursor(cursor string) ApiGetCustomContentByTypeInBlogPostRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Limit(limit int32) ApiGetCustomContentByTypeInBlogPostRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInBlogPostRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInBlogPostRequest {
	r.bodyFormat = &bodyFormat
	return r
}

func (r ApiGetCustomContentByTypeInBlogPostRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInBlogPostExecute(r)
}

/*
GetCustomContentByTypeInBlogPost Get custom content by type in blog post

Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post for which custom content should be returned.
 @return ApiGetCustomContentByTypeInBlogPostRequest
*/
func (a *CustomContentAPIService) GetCustomContentByTypeInBlogPost(ctx context.Context, id int64) ApiGetCustomContentByTypeInBlogPostRequest {
	return ApiGetCustomContentByTypeInBlogPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultCustomContent
func (a *CustomContentAPIService) GetCustomContentByTypeInBlogPostExecute(r ApiGetCustomContentByTypeInBlogPostRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.GetCustomContentByTypeInBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInPageRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	type_ *string
	sort *CustomContentSortOrder
	cursor *string
	limit *int32
	bodyFormat *CustomContentBodyRepresentation
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInPageRequest) Type_(type_ string) ApiGetCustomContentByTypeInPageRequest {
	r.type_ = &type_
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentByTypeInPageRequest) Sort(sort CustomContentSortOrder) ApiGetCustomContentByTypeInPageRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInPageRequest) Cursor(cursor string) ApiGetCustomContentByTypeInPageRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInPageRequest) Limit(limit int32) ApiGetCustomContentByTypeInPageRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInPageRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInPageRequest {
	r.bodyFormat = &bodyFormat
	return r
}

func (r ApiGetCustomContentByTypeInPageRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInPageExecute(r)
}

/*
GetCustomContentByTypeInPage Get custom content by type in page

Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content (page), and the corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page for which custom content should be returned.
 @return ApiGetCustomContentByTypeInPageRequest
*/
func (a *CustomContentAPIService) GetCustomContentByTypeInPage(ctx context.Context, id int64) ApiGetCustomContentByTypeInPageRequest {
	return ApiGetCustomContentByTypeInPageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultCustomContent
func (a *CustomContentAPIService) GetCustomContentByTypeInPageExecute(r ApiGetCustomContentByTypeInPageRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.GetCustomContentByTypeInPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInSpaceRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	type_ *string
	cursor *string
	limit *int32
	bodyFormat *CustomContentBodyRepresentation
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInSpaceRequest) Type_(type_ string) ApiGetCustomContentByTypeInSpaceRequest {
	r.type_ = &type_
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInSpaceRequest) Cursor(cursor string) ApiGetCustomContentByTypeInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInSpaceRequest) Limit(limit int32) ApiGetCustomContentByTypeInSpaceRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInSpaceRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

func (r ApiGetCustomContentByTypeInSpaceRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInSpaceExecute(r)
}

/*
GetCustomContentByTypeInSpace Get custom content by type in space

Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content and the corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which custom content should be returned.
 @return ApiGetCustomContentByTypeInSpaceRequest
*/
func (a *CustomContentAPIService) GetCustomContentByTypeInSpace(ctx context.Context, id int64) ApiGetCustomContentByTypeInSpaceRequest {
	return ApiGetCustomContentByTypeInSpaceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultCustomContent
func (a *CustomContentAPIService) GetCustomContentByTypeInSpaceExecute(r ApiGetCustomContentByTypeInSpaceRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.GetCustomContentByTypeInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomContentRequest struct {
	ctx context.Context
	ApiService *CustomContentAPIService
	id int64
	updateCustomContentRequest *UpdateCustomContentRequest
}

func (r ApiUpdateCustomContentRequest) UpdateCustomContentRequest(updateCustomContentRequest UpdateCustomContentRequest) ApiUpdateCustomContentRequest {
	r.updateCustomContentRequest = &updateCustomContentRequest
	return r
}

func (r ApiUpdateCustomContentRequest) Execute() (*CreateCustomContent201Response, *http.Response, error) {
	return r.ApiService.UpdateCustomContentExecute(r)
}

/*
UpdateCustomContent Update custom content

Update a custom content by id.
At most one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
Note that if `spaceId` is specified, it must be the same as the `spaceId` used for creating the custom content
as moving custom content to a different space is not supported.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
 @return ApiUpdateCustomContentRequest
*/
func (a *CustomContentAPIService) UpdateCustomContent(ctx context.Context, id int64) ApiUpdateCustomContentRequest {
	return ApiUpdateCustomContentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateCustomContent201Response
func (a *CustomContentAPIService) UpdateCustomContentExecute(r ApiUpdateCustomContentRequest) (*CreateCustomContent201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCustomContent201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentAPIService.UpdateCustomContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCustomContentRequest == nil {
		return localVarReturnValue, nil, reportError("updateCustomContentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCustomContentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

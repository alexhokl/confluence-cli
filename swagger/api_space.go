/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SpaceAPIService SpaceAPI service
type SpaceAPIService service

type ApiCreateSpaceRequest struct {
	ctx context.Context
	ApiService *SpaceAPIService
	createSpaceRequest *CreateSpaceRequest
}

func (r ApiCreateSpaceRequest) CreateSpaceRequest(createSpaceRequest CreateSpaceRequest) ApiCreateSpaceRequest {
	r.createSpaceRequest = &createSpaceRequest
	return r
}

func (r ApiCreateSpaceRequest) Execute() (*CreateSpace201Response, *http.Response, error) {
	return r.ApiService.CreateSpaceExecute(r)
}

/*
CreateSpace Create space

Creates a Space as specified in the payload.

Available as part of the [Role-Based Access Controls Beta](https://community.atlassian.com/forums/Confluence-articles/Beta-Simplify-space-access-in-Confluence-with-roles/ba-p/3044550). 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to create spaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSpaceRequest
*/
func (a *SpaceAPIService) CreateSpace(ctx context.Context) ApiCreateSpaceRequest {
	return ApiCreateSpaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSpace201Response
func (a *SpaceAPIService) CreateSpaceExecute(r ApiCreateSpaceRequest) (*CreateSpace201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSpace201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceAPIService.CreateSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSpaceRequest == nil {
		return localVarReturnValue, nil, reportError("createSpaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSpaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceByIdRequest struct {
	ctx context.Context
	ApiService *SpaceAPIService
	id int64
	descriptionFormat *SpaceDescriptionBodyRepresentation
	includeIcon *bool
	includeOperations *bool
	includeProperties *bool
	includePermissions *bool
	includeRoleAssignments *bool
	includeLabels *bool
}

// The content format type to be returned in the &#x60;description&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;description&#x60; field.
func (r ApiGetSpaceByIdRequest) DescriptionFormat(descriptionFormat SpaceDescriptionBodyRepresentation) ApiGetSpaceByIdRequest {
	r.descriptionFormat = &descriptionFormat
	return r
}

// If the icon for the space should be fetched or not.
func (r ApiGetSpaceByIdRequest) IncludeIcon(includeIcon bool) ApiGetSpaceByIdRequest {
	r.includeIcon = &includeIcon
	return r
}

// Includes operations associated with this space in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetSpaceByIdRequest) IncludeOperations(includeOperations bool) ApiGetSpaceByIdRequest {
	r.includeOperations = &includeOperations
	return r
}

// Includes space properties associated with this space in the response. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetSpaceByIdRequest) IncludeProperties(includeProperties bool) ApiGetSpaceByIdRequest {
	r.includeProperties = &includeProperties
	return r
}

// Includes space permissions associated with this space in the response. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetSpaceByIdRequest) IncludePermissions(includePermissions bool) ApiGetSpaceByIdRequest {
	r.includePermissions = &includePermissions
	return r
}

// Includes role assignments associated with this space in the response. This parameter is only accepted for EAP sites. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetSpaceByIdRequest) IncludeRoleAssignments(includeRoleAssignments bool) ApiGetSpaceByIdRequest {
	r.includeRoleAssignments = &includeRoleAssignments
	return r
}

// Includes labels associated with this space in the response. The number of results will be limited to 50 and sorted in the default sort order. A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
func (r ApiGetSpaceByIdRequest) IncludeLabels(includeLabels bool) ApiGetSpaceByIdRequest {
	r.includeLabels = &includeLabels
	return r
}

func (r ApiGetSpaceByIdRequest) Execute() (*GetSpaceById200Response, *http.Response, error) {
	return r.ApiService.GetSpaceByIdExecute(r)
}

/*
GetSpaceById Get space by id

Returns a specific space.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space to be returned.
 @return ApiGetSpaceByIdRequest
*/
func (a *SpaceAPIService) GetSpaceById(ctx context.Context, id int64) ApiGetSpaceByIdRequest {
	return ApiGetSpaceByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetSpaceById200Response
func (a *SpaceAPIService) GetSpaceByIdExecute(r ApiGetSpaceByIdRequest) (*GetSpaceById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSpaceById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceAPIService.GetSpaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description-format", r.descriptionFormat, "form", "")
	}
	if r.includeIcon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-icon", r.includeIcon, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-icon", defaultValue, "form", "")
		r.includeIcon = &defaultValue
	}
	if r.includeOperations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", r.includeOperations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-operations", defaultValue, "form", "")
		r.includeOperations = &defaultValue
	}
	if r.includeProperties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", r.includeProperties, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-properties", defaultValue, "form", "")
		r.includeProperties = &defaultValue
	}
	if r.includePermissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-permissions", r.includePermissions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-permissions", defaultValue, "form", "")
		r.includePermissions = &defaultValue
	}
	if r.includeRoleAssignments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-role-assignments", r.includeRoleAssignments, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-role-assignments", defaultValue, "form", "")
		r.includeRoleAssignments = &defaultValue
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", r.includeLabels, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-labels", defaultValue, "form", "")
		r.includeLabels = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpacesRequest struct {
	ctx context.Context
	ApiService *SpaceAPIService
	ids *[]int64
	keys *[]string
	type_ *string
	status *string
	labels *[]string
	favoritedBy *string
	notFavoritedBy *string
	sort *SpaceSortOrder
	descriptionFormat *SpaceDescriptionBodyRepresentation
	includeIcon *bool
	cursor *string
	limit *int32
}

// Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.
func (r ApiGetSpacesRequest) Ids(ids []int64) ApiGetSpacesRequest {
	r.ids = &ids
	return r
}

// Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.
func (r ApiGetSpacesRequest) Keys(keys []string) ApiGetSpacesRequest {
	r.keys = &keys
	return r
}

// Filter the results to spaces based on their type.
func (r ApiGetSpacesRequest) Type_(type_ string) ApiGetSpacesRequest {
	r.type_ = &type_
	return r
}

// Filter the results to spaces based on their status.
func (r ApiGetSpacesRequest) Status(status string) ApiGetSpacesRequest {
	r.status = &status
	return r
}

// Filter the results to spaces based on their labels. Multiple labels can be specified as a comma-separated list.
func (r ApiGetSpacesRequest) Labels(labels []string) ApiGetSpacesRequest {
	r.labels = &labels
	return r
}

// Filter the results to spaces favorited by the user with the specified account ID.
func (r ApiGetSpacesRequest) FavoritedBy(favoritedBy string) ApiGetSpacesRequest {
	r.favoritedBy = &favoritedBy
	return r
}

// Filter the results to spaces NOT favorited by the user with the specified account ID.
func (r ApiGetSpacesRequest) NotFavoritedBy(notFavoritedBy string) ApiGetSpacesRequest {
	r.notFavoritedBy = &notFavoritedBy
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetSpacesRequest) Sort(sort SpaceSortOrder) ApiGetSpacesRequest {
	r.sort = &sort
	return r
}

// The content format type to be returned in the &#x60;description&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;description&#x60; field.
func (r ApiGetSpacesRequest) DescriptionFormat(descriptionFormat SpaceDescriptionBodyRepresentation) ApiGetSpacesRequest {
	r.descriptionFormat = &descriptionFormat
	return r
}

// If the icon for the space should be fetched or not.
func (r ApiGetSpacesRequest) IncludeIcon(includeIcon bool) ApiGetSpacesRequest {
	r.includeIcon = &includeIcon
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetSpacesRequest) Cursor(cursor string) ApiGetSpacesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of spaces per result to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
func (r ApiGetSpacesRequest) Limit(limit int32) ApiGetSpacesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSpacesRequest) Execute() (*MultiEntityResultSpace, *http.Response, error) {
	return r.ApiService.GetSpacesExecute(r)
}

/*
GetSpaces Get spaces

Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
additional results (if available) will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only spaces that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpacesRequest
*/
func (a *SpaceAPIService) GetSpaces(ctx context.Context) ApiGetSpacesRequest {
	return ApiGetSpacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultSpace
func (a *SpaceAPIService) GetSpacesExecute(r ApiGetSpacesRequest) (*MultiEntityResultSpace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultSpace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpaceAPIService.GetSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.favoritedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "favorited-by", r.favoritedBy, "form", "")
	}
	if r.notFavoritedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not-favorited-by", r.notFavoritedBy, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.descriptionFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description-format", r.descriptionFormat, "form", "")
	}
	if r.includeIcon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-icon", r.includeIcon, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-icon", defaultValue, "form", "")
		r.includeIcon = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

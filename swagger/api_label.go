/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LabelAPIService LabelAPI service
type LabelAPIService service

type ApiGetAttachmentLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetAttachmentLabelsRequest) Prefix(prefix string) ApiGetAttachmentLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetAttachmentLabelsRequest) Sort(sort []LabelSortOrder) ApiGetAttachmentLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetAttachmentLabelsRequest) Cursor(cursor string) ApiGetAttachmentLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetAttachmentLabelsRequest) Limit(limit int32) ApiGetAttachmentLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetAttachmentLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetAttachmentLabelsExecute(r)
}

/*
GetAttachmentLabels Get labels for attachment

Returns the labels of specific attachment. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the parent content of the attachment and its corresponding space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the attachment for which labels should be returned.
 @return ApiGetAttachmentLabelsRequest
*/
func (a *LabelAPIService) GetAttachmentLabels(ctx context.Context, id int64) ApiGetAttachmentLabelsRequest {
	return ApiGetAttachmentLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetAttachmentLabelsExecute(r ApiGetAttachmentLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetAttachmentLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetBlogPostLabelsRequest) Prefix(prefix string) ApiGetBlogPostLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostLabelsRequest) Sort(sort []LabelSortOrder) ApiGetBlogPostLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostLabelsRequest) Cursor(cursor string) ApiGetBlogPostLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostLabelsRequest) Limit(limit int32) ApiGetBlogPostLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBlogPostLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetBlogPostLabelsExecute(r)
}

/*
GetBlogPostLabels Get labels for blog post

Returns the labels of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the blog post and its corresponding space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post for which labels should be returned.
 @return ApiGetBlogPostLabelsRequest
*/
func (a *LabelAPIService) GetBlogPostLabels(ctx context.Context, id int64) ApiGetBlogPostLabelsRequest {
	return ApiGetBlogPostLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetBlogPostLabelsExecute(r ApiGetBlogPostLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetBlogPostLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetCustomContentLabelsRequest) Prefix(prefix string) ApiGetCustomContentLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentLabelsRequest) Sort(sort []LabelSortOrder) ApiGetCustomContentLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentLabelsRequest) Cursor(cursor string) ApiGetCustomContentLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentLabelsRequest) Limit(limit int32) ApiGetCustomContentLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCustomContentLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetCustomContentLabelsExecute(r)
}

/*
GetCustomContentLabels Get labels for custom content

Returns the labels for a specific piece of custom content. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content and its corresponding space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the custom content for which labels should be returned.
 @return ApiGetCustomContentLabelsRequest
*/
func (a *LabelAPIService) GetCustomContentLabels(ctx context.Context, id int64) ApiGetCustomContentLabelsRequest {
	return ApiGetCustomContentLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetCustomContentLabelsExecute(r ApiGetCustomContentLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetCustomContentLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	labelId *[]int64
	prefix *[]string
	cursor *string
	sort *[]LabelSortOrder
	limit *int32
}

// Filters on label ID. Multiple IDs can be specified as a comma-separated list.
func (r ApiGetLabelsRequest) LabelId(labelId []int64) ApiGetLabelsRequest {
	r.labelId = &labelId
	return r
}

// Filters on label prefix. Multiple IDs can be specified as a comma-separated list.
func (r ApiGetLabelsRequest) Prefix(prefix []string) ApiGetLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetLabelsRequest) Cursor(cursor string) ApiGetLabelsRequest {
	r.cursor = &cursor
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetLabelsRequest) Sort(sort []LabelSortOrder) ApiGetLabelsRequest {
	r.sort = &sort
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetLabelsRequest) Limit(limit int32) ApiGetLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetLabelsExecute(r)
}

/*
GetLabels Get labels

Returns all labels. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLabelsRequest
*/
func (a *LabelAPIService) GetLabels(ctx context.Context) ApiGetLabelsRequest {
	return ApiGetLabelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetLabelsExecute(r ApiGetLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.labelId != nil {
		t := *r.labelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "label-id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "label-id", t, "form", "multi")
		}
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetPageLabelsRequest) Prefix(prefix string) ApiGetPageLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageLabelsRequest) Sort(sort []LabelSortOrder) ApiGetPageLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageLabelsRequest) Cursor(cursor string) ApiGetPageLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageLabelsRequest) Limit(limit int32) ApiGetPageLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPageLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetPageLabelsExecute(r)
}

/*
GetPageLabels Get labels for page

Returns the labels of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page for which labels should be returned.
 @return ApiGetPageLabelsRequest
*/
func (a *LabelAPIService) GetPageLabels(ctx context.Context, id int64) ApiGetPageLabelsRequest {
	return ApiGetPageLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetPageLabelsExecute(r ApiGetPageLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetPageLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceContentLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetSpaceContentLabelsRequest) Prefix(prefix string) ApiGetSpaceContentLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetSpaceContentLabelsRequest) Sort(sort []LabelSortOrder) ApiGetSpaceContentLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetSpaceContentLabelsRequest) Cursor(cursor string) ApiGetSpaceContentLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetSpaceContentLabelsRequest) Limit(limit int32) ApiGetSpaceContentLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSpaceContentLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetSpaceContentLabelsExecute(r)
}

/*
GetSpaceContentLabels Get labels for space content

Returns the labels of space content (pages, blogposts etc). The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which labels should be returned.
 @return ApiGetSpaceContentLabelsRequest
*/
func (a *LabelAPIService) GetSpaceContentLabels(ctx context.Context, id int64) ApiGetSpaceContentLabelsRequest {
	return ApiGetSpaceContentLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetSpaceContentLabelsExecute(r ApiGetSpaceContentLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetSpaceContentLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/content/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	} else {
		var defaultValue string = "my, team"
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", defaultValue, "form", "")
		r.prefix = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceLabelsRequest struct {
	ctx context.Context
	ApiService *LabelAPIService
	id int64
	prefix *string
	sort *[]LabelSortOrder
	cursor *string
	limit *int32
}

// Filter the results to labels based on their prefix.
func (r ApiGetSpaceLabelsRequest) Prefix(prefix string) ApiGetSpaceLabelsRequest {
	r.prefix = &prefix
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetSpaceLabelsRequest) Sort(sort []LabelSortOrder) ApiGetSpaceLabelsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetSpaceLabelsRequest) Cursor(cursor string) ApiGetSpaceLabelsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of labels per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetSpaceLabelsRequest) Limit(limit int32) ApiGetSpaceLabelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSpaceLabelsRequest) Execute() (*MultiEntityResultLabel, *http.Response, error) {
	return r.ApiService.GetSpaceLabelsExecute(r)
}

/*
GetSpaceLabels Get labels for space

Returns the labels of specific space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the space.
Only labels that the user has permission to view will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the space for which labels should be returned.
 @return ApiGetSpaceLabelsRequest
*/
func (a *LabelAPIService) GetSpaceLabels(ctx context.Context, id int64) ApiGetSpaceLabelsRequest {
	return ApiGetSpaceLabelsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultLabel
func (a *LabelAPIService) GetSpaceLabelsExecute(r ApiGetSpaceLabelsRequest) (*MultiEntityResultLabel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultLabel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LabelAPIService.GetSpaceLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	} else {
		var defaultValue string = "my, team"
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", defaultValue, "form", "")
		r.prefix = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

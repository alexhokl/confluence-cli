/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swagger

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VersionAPIService VersionAPI service
type VersionAPIService service

type ApiGetAttachmentVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	attachmentId string
	versionNumber int64
}

func (r ApiGetAttachmentVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetAttachmentVersionDetailsExecute(r)
}

/*
GetAttachmentVersionDetails Get version details for attachment version

Retrieves version details for the specified attachment and version number.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the attachment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId The ID of the attachment for which version details should be returned.
 @param versionNumber The version number of the attachment to be returned.
 @return ApiGetAttachmentVersionDetailsRequest
*/
func (a *VersionAPIService) GetAttachmentVersionDetails(ctx context.Context, attachmentId string, versionNumber int64) ApiGetAttachmentVersionDetailsRequest {
	return ApiGetAttachmentVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetAttachmentVersionDetailsExecute(r ApiGetAttachmentVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetAttachmentVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{attachment-id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachment-id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttachmentVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id string
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetAttachmentVersionsRequest) Cursor(cursor string) ApiGetAttachmentVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetAttachmentVersionsRequest) Limit(limit int32) ApiGetAttachmentVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetAttachmentVersionsRequest) Sort(sort VersionSortOrder) ApiGetAttachmentVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetAttachmentVersionsRequest) Execute() (*MultiEntityResultVersion, *http.Response, error) {
	return r.ApiService.GetAttachmentVersionsExecute(r)
}

/*
GetAttachmentVersions Get attachment versions

Returns the versions of specific attachment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the attachment and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the attachment to be queried for its versions. If you don't know the attachment ID, use Get attachments and filter the results.
 @return ApiGetAttachmentVersionsRequest
*/
func (a *VersionAPIService) GetAttachmentVersions(ctx context.Context, id string) ApiGetAttachmentVersionsRequest {
	return ApiGetAttachmentVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion
func (a *VersionAPIService) GetAttachmentVersionsExecute(r ApiGetAttachmentVersionsRequest) (*MultiEntityResultVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetAttachmentVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	blogpostId int64
	versionNumber int64
}

func (r ApiGetBlogPostVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetBlogPostVersionDetailsExecute(r)
}

/*
GetBlogPostVersionDetails Get version details for blog post version

Retrieves version details for the specified blog post and version number.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogpostId The ID of the blog post for which version details should be returned.
 @param versionNumber The version number of the blog post to be returned.
 @return ApiGetBlogPostVersionDetailsRequest
*/
func (a *VersionAPIService) GetBlogPostVersionDetails(ctx context.Context, blogpostId int64, versionNumber int64) ApiGetBlogPostVersionDetailsRequest {
	return ApiGetBlogPostVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		blogpostId: blogpostId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetBlogPostVersionDetailsExecute(r ApiGetBlogPostVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetBlogPostVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{blogpost-id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogpost-id"+"}", url.PathEscape(parameterValueToString(r.blogpostId, "blogpostId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostVersionsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostVersionsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostVersionsRequest) Cursor(cursor string) ApiGetBlogPostVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostVersionsRequest) Limit(limit int32) ApiGetBlogPostVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostVersionsRequest) Sort(sort VersionSortOrder) ApiGetBlogPostVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetBlogPostVersionsRequest) Execute() (*MultiEntityResultVersion1, *http.Response, error) {
	return r.ApiService.GetBlogPostVersionsExecute(r)
}

/*
GetBlogPostVersions Get blog post versions

Returns the versions of specific blog post. 

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the blog post to be queried for its versions. If you don't know the blog post ID, use Get blog posts and filter the results.
 @return ApiGetBlogPostVersionsRequest
*/
func (a *VersionAPIService) GetBlogPostVersions(ctx context.Context, id int64) ApiGetBlogPostVersionsRequest {
	return ApiGetBlogPostVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion1
func (a *VersionAPIService) GetBlogPostVersionsExecute(r ApiGetBlogPostVersionsRequest) (*MultiEntityResultVersion1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetBlogPostVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	customContentId int64
	versionNumber int64
}

func (r ApiGetCustomContentVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetCustomContentVersionDetailsExecute(r)
}

/*
GetCustomContentVersionDetails Get version details for custom content version

Retrieves version details for the specified custom content and version number.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content for which version details should be returned.
 @param versionNumber The version number of the custom content to be returned.
 @return ApiGetCustomContentVersionDetailsRequest
*/
func (a *VersionAPIService) GetCustomContentVersionDetails(ctx context.Context, customContentId int64, versionNumber int64) ApiGetCustomContentVersionDetailsRequest {
	return ApiGetCustomContentVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetCustomContentVersionDetailsExecute(r ApiGetCustomContentVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetCustomContentVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	customContentId int64
	bodyFormat *CustomContentBodyRepresentation
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentVersionsRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentVersionsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentVersionsRequest) Cursor(cursor string) ApiGetCustomContentVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentVersionsRequest) Limit(limit int32) ApiGetCustomContentVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetCustomContentVersionsRequest) Sort(sort VersionSortOrder) ApiGetCustomContentVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCustomContentVersionsRequest) Execute() (*MultiEntityResultVersion3, *http.Response, error) {
	return r.ApiService.GetCustomContentVersionsExecute(r)
}

/*
GetCustomContentVersions Get custom content versions

Returns the versions of specific custom content.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content and its corresponding page and space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customContentId The ID of the custom content to be queried for its versions. If you don't know the custom content ID, use Get custom-content by type and filter the results.
 @return ApiGetCustomContentVersionsRequest
*/
func (a *VersionAPIService) GetCustomContentVersions(ctx context.Context, customContentId int64) ApiGetCustomContentVersionsRequest {
	return ApiGetCustomContentVersionsRequest{
		ApiService: a,
		ctx: ctx,
		customContentId: customContentId,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion3
func (a *VersionAPIService) GetCustomContentVersionsExecute(r ApiGetCustomContentVersionsRequest) (*MultiEntityResultVersion3, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetCustomContentVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{custom-content-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"custom-content-id"+"}", url.PathEscape(parameterValueToString(r.customContentId, "customContentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	versionNumber int64
}

func (r ApiGetFooterCommentVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetFooterCommentVersionDetailsExecute(r)
}

/*
GetFooterCommentVersionDetails Get version details for footer comment version

Retrieves version details for the specified footer comment version.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the footer comment for which version details should be returned.
 @param versionNumber The version number of the footer comment to be returned.
 @return ApiGetFooterCommentVersionDetailsRequest
*/
func (a *VersionAPIService) GetFooterCommentVersionDetails(ctx context.Context, id int64, versionNumber int64) ApiGetFooterCommentVersionDetailsRequest {
	return ApiGetFooterCommentVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetFooterCommentVersionDetailsExecute(r ApiGetFooterCommentVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetFooterCommentVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentVersionsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetFooterCommentVersionsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetFooterCommentVersionsRequest) Cursor(cursor string) ApiGetFooterCommentVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetFooterCommentVersionsRequest) Limit(limit int32) ApiGetFooterCommentVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetFooterCommentVersionsRequest) Sort(sort VersionSortOrder) ApiGetFooterCommentVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetFooterCommentVersionsRequest) Execute() (*MultiEntityResultVersion4, *http.Response, error) {
	return r.ApiService.GetFooterCommentVersionsExecute(r)
}

/*
GetFooterCommentVersions Get footer comment versions

Retrieves the versions of the specified footer comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the footer comment for which versions should be returned
 @return ApiGetFooterCommentVersionsRequest
*/
func (a *VersionAPIService) GetFooterCommentVersions(ctx context.Context, id int64) ApiGetFooterCommentVersionsRequest {
	return ApiGetFooterCommentVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion4
func (a *VersionAPIService) GetFooterCommentVersionsExecute(r ApiGetFooterCommentVersionsRequest) (*MultiEntityResultVersion4, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion4
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetFooterCommentVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	versionNumber int64
}

func (r ApiGetInlineCommentVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetInlineCommentVersionDetailsExecute(r)
}

/*
GetInlineCommentVersionDetails Get version details for inline comment version

Retrieves version details for the specified inline comment version.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the inline comment for which version details should be returned.
 @param versionNumber The version number of the inline comment to be returned.
 @return ApiGetInlineCommentVersionDetailsRequest
*/
func (a *VersionAPIService) GetInlineCommentVersionDetails(ctx context.Context, id int64, versionNumber int64) ApiGetInlineCommentVersionDetailsRequest {
	return ApiGetInlineCommentVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetInlineCommentVersionDetailsExecute(r ApiGetInlineCommentVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetInlineCommentVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentVersionsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetInlineCommentVersionsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetInlineCommentVersionsRequest) Cursor(cursor string) ApiGetInlineCommentVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetInlineCommentVersionsRequest) Limit(limit int32) ApiGetInlineCommentVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetInlineCommentVersionsRequest) Sort(sort VersionSortOrder) ApiGetInlineCommentVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetInlineCommentVersionsRequest) Execute() (*MultiEntityResultVersion4, *http.Response, error) {
	return r.ApiService.GetInlineCommentVersionsExecute(r)
}

/*
GetInlineCommentVersions Get inline comment versions

Retrieves the versions of the specified inline comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blog post and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the inline comment for which versions should be returned
 @return ApiGetInlineCommentVersionsRequest
*/
func (a *VersionAPIService) GetInlineCommentVersions(ctx context.Context, id int64) ApiGetInlineCommentVersionsRequest {
	return ApiGetInlineCommentVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion4
func (a *VersionAPIService) GetInlineCommentVersionsExecute(r ApiGetInlineCommentVersionsRequest) (*MultiEntityResultVersion4, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion4
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetInlineCommentVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageVersionDetailsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	pageId int64
	versionNumber int64
}

func (r ApiGetPageVersionDetailsRequest) Execute() (*DetailedVersion, *http.Response, error) {
	return r.ApiService.GetPageVersionDetailsExecute(r)
}

/*
GetPageVersionDetails Get version details for page version

Retrieves version details for the specified page and version number.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId The ID of the page for which version details should be returned.
 @param versionNumber The version number of the page to be returned.
 @return ApiGetPageVersionDetailsRequest
*/
func (a *VersionAPIService) GetPageVersionDetails(ctx context.Context, pageId int64, versionNumber int64) ApiGetPageVersionDetailsRequest {
	return ApiGetPageVersionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
//  @return DetailedVersion
func (a *VersionAPIService) GetPageVersionDetailsExecute(r ApiGetPageVersionDetailsRequest) (*DetailedVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DetailedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetPageVersionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{page-id}/versions/{version-number}"
	localVarPath = strings.Replace(localVarPath, "{"+"page-id"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version-number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageVersionsRequest struct {
	ctx context.Context
	ApiService *VersionAPIService
	id int64
	bodyFormat *PrimaryBodyRepresentation
	cursor *string
	limit *int32
	sort *VersionSortOrder
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageVersionsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageVersionsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageVersionsRequest) Cursor(cursor string) ApiGetPageVersionsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of versions per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageVersionsRequest) Limit(limit int32) ApiGetPageVersionsRequest {
	r.limit = &limit
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageVersionsRequest) Sort(sort VersionSortOrder) ApiGetPageVersionsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPageVersionsRequest) Execute() (*MultiEntityResultVersion2, *http.Response, error) {
	return r.ApiService.GetPageVersionsExecute(r)
}

/*
GetPageVersions Get page versions

Returns the versions of specific page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the page to be queried for its versions. If you don't know the page ID, use Get pages and filter the results.
 @return ApiGetPageVersionsRequest
*/
func (a *VersionAPIService) GetPageVersions(ctx context.Context, id int64) ApiGetPageVersionsRequest {
	return ApiGetPageVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MultiEntityResultVersion2
func (a *VersionAPIService) GetPageVersionsExecute(r ApiGetPageVersionsRequest) (*MultiEntityResultVersion2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiEntityResultVersion2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionAPIService.GetPageVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
